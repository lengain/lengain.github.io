<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>8086汇编常用知识手册</title>
    <url>/2020/08/07/8086%E6%B1%87%E7%BC%96%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<p>8086 16位CPU 80386 32位CPU（王爽 《汇编语言》）<br>AT&amp;T汇编（Mac，iOS模拟器）<br>ARM汇编 （嵌入式，iOS设备）</p>
<h3 id="基础知识小结"><a href="#基础知识小结" class="headerlink" title="基础知识小结"></a>基础知识小结</h3><p>（1）汇编指令是机器指令的助记符，同机器指令一一对应<br>（2）存储器中指令和数据没有区别，都是二进制信息<br>（3）存储单元从零开始顺序编号<br>（4）一个存储单元可以存储8个bit，即8位二进制数<br>（5）1Byte = 8bit  1KB = 1024Byte  1MB = 1024 KB  1GB = 1024MB<br>（6）地址总线的宽度决定了CPU的寻址能力；数据总线的宽度决定了CPU与其他器件进行数据传送时的一次数据传送量；控制总线的宽度决定了CPU对系统中其他器件的控制能力。</p>
<a id="more"></a>
<p>（7）8086PC的内存地址空间分配的基本情况<br><img src="/2020/08/07/8086%E6%B1%87%E7%BC%96%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E6%89%8B%E5%86%8C/内存地址空间分配.png" width="200"><br>（8）dword:双字型 32位 ffff ffff<br>&emsp;&emsp;&emsp;word：字型 16位  ffff<br>&emsp;&emsp;&emsp;字节型     8 位ff<br>&emsp;&emsp;&emsp;ax  字型 16位 ffff<br>&emsp;&emsp;&emsp;ah 字节型 8位ff<br>&emsp;&emsp;&emsp;db 字节型数据 ff<br>&emsp;&emsp;&emsp;dw 字形数据 ffff<br>&emsp;&emsp;&emsp;dd 双字型数据 ffff ffff</p>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><h4 id="寄存器知识小结"><a href="#寄存器知识小结" class="headerlink" title="寄存器知识小结"></a>寄存器知识小结</h4><ol>
<li><p>在进行数据传送或运算是，要注意指令的两个操作对象的位数应当是一致的。</p>
</li>
<li><p>CPU通过地址总线访问存储器，8086CPU有20位地址总线，因此需要两个16位地址来形成20位的物理地址。</p>
</li>
<li><p>地址加法器采用物理地址=段地址x16+偏移地址的方法来合成物理地址的。</p>
</li>
<li><p>关于段地址为什么要左移4位（x16）：因为段地址本身和偏移地址都是16位的，而8086有20位的地址总线，因此段地址偏移四位之后，变为20位数。</p>
</li>
<li><p>物理地址=段地址x16+偏移地址的本质含义是：CPU在访问内存时，用一个基础地址（段地址x16）和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址。</p>
</li>
<li><p>8086机中，任意时刻，CPU将CS:IP （Code Segment: Instruction Pointer）指向的内容当做指令执行。其中，CS为代码段寄存器，IP为指令指针寄存器。</p>
</li>
<li><p>DS（Data Segmet）寄存器 是段寄存器，通常用来存放要访问数据的段地址。</p>
</li>
<li><p>“[···]”表示一个内存单元。方括号中表示内存单元的偏移地址。比如读取10000H中的内容，可以使用以下程序段:<br>mov bx,1000H<br>mov ds,<br>bx mov al,[0]</p>
</li>
<li><p>字在内存中存储时，要用两个地址连续的内存单元来存放，字的低位字节存放在低地址单元中，高位字节存放在高地址单元中。</p>
</li>
<li><p>任意时刻，SS:SP指向栈顶元素。SS（Stack Segment）为栈 段寄存器，SP（Stack Point） 为栈指针寄存器</p>
</li>
<li><p>一个栈段的容量最大为64KB，0000~ffff。2^10 ∙ 2^6 = 64KB</p>
</li>
<li><p>CPU将内存中的某段内容当做代码，是因为CS:IP指向了那里；CPU将某段内存当做栈，是因为SS:SP指向了那里。</p>
</li>
<li><p>si和di是和bx功能相近的寄存器，si和di不能够分成两个8位寄存器来使用</p>
</li>
<li><p>[ idata ] 用一个常量来表示地址， 可用于直接定位一个内存单元 ;<br>[ bx ]用一个变量来表示内存地址， 可用于间接定位一个内存单元;<br>[ bx+idata ] 用一个变量和常量表示地址， 可在一个起始地址的基础上用变量间接定位一个内存单元 ;<br>[ bx + si ] 用 两 个 变 量 表 示 地 址 ;<br>[ bx + si + idata ] 用两个变量和一 个常量表示地址。</p>
</li>
<li><p>reg：ax,bx,cx,dx,sp,bp,si,di        sreg:ds,ss,cs,es</p>
</li>
<li><p>[….]寻址方式只有4个寄存器支持，分别是bx，si，di，bp。这四个寄存器只能单独出现或以4个组合出现：bx和si，bx和di，bp和si，bp和di。</p>
</li>
<li><p>只要在[ …. ]中使用寄存器bp，而指令中没有显性地给出段地址，段地址就默认在ss中。</p>
</li>
<li><p>在没有寄存器名存在的情况下，用操作符X ptr 指明内存单元的长度，X在汇编指令中可以为word或byte</p>
</li>
</ol>
<h5 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h5><table>
<thead>
<tr>
<th>标志位</th>
<th>名称及全称</th>
<th>=1</th>
<th>=0</th>
</tr>
</thead>
<tbody><tr>
<td>CF</td>
<td>无符号/进位借位标志/Carry Flag</td>
<td>CY/Carry/进位</td>
<td>NC/No Carry/无进位</td>
</tr>
<tr>
<td>PF</td>
<td>奇偶标志/Parity Flag</td>
<td>PE/Parity Even/1的个数/偶</td>
<td>PO/Parity Odd/奇</td>
</tr>
<tr>
<td>AF</td>
<td>辅助进位标志/Auxiliary Carry Flag</td>
<td>AC/Auxiliary Carry/进位</td>
<td>NA/No Auxiliary Carry/无进位</td>
</tr>
<tr>
<td>ZF</td>
<td>零标志/Zero Flag</td>
<td>ZR/Zero/运算结果/等于零</td>
<td>NZ/Not Zero/不等于零</td>
</tr>
<tr>
<td>SF</td>
<td>符号标志/Sign Flag</td>
<td>NG/Negative/负</td>
<td>PL/Positive/非负</td>
</tr>
<tr>
<td>TF</td>
<td>跟踪标志/Trace Flag</td>
<td></td>
<td></td>
</tr>
<tr>
<td>IF</td>
<td>中断标志/Interrupt Flag</td>
<td>EI/Enable Interrupt/允许</td>
<td>DI/Disable Interrupt/禁止</td>
</tr>
<tr>
<td>DF</td>
<td>方向标志/Direction Flag</td>
<td>DN/Down/减少</td>
<td>UP/增加</td>
</tr>
<tr>
<td>OF</td>
<td>有符号/溢出标志/Overflow Flag</td>
<td>OV/Overflow/溢出</td>
<td>NV/Not Overflow/未溢出</td>
</tr>
</tbody></table>
<h4 id="DEBUG命令"><a href="#DEBUG命令" class="headerlink" title="DEBUG命令"></a>DEBUG命令</h4><p>用DEBUG program.exe来用汇编调试一个程序<br>DEBUG默认所有的数据都用十六进制表示。</p>
<ol>
<li>r 查看CPU寄存器中的内容<br>r ax 修改寄存器ax中的值</li>
<li>d 段地址:偏移地址 查看该内存处的内容<br>d 段地址:偏移地址 结尾偏移地址 查看该内存范围的内容<br>使用d 段地址:偏移地址之后，接着使用d命令，可列出后续的内容</li>
<li>e 改写内存中的内容<br>“e 起始地址 数据 数据 数据 …”的格式</li>
<li>t 命令，让CPU执行当前CS:IP指向的汇编命令<br>用U命令查看内存中机器码的含义，用T命令执行内存中的机器码</li>
<li>a 段地址:偏移地址 以汇编指令的形式在内存中写入机器指令的</li>
<li>注意：Debug的T命令在执行修改寄存器SS的指令时，下一条指令也紧接着被执行。</li>
<li>g 命令 “g 0012”将使Debug从当前CS:IP指向的指令执行，一直到(IP)=0012h位置。</li>
</ol>
<h5 id="DEBUG常用命令"><a href="#DEBUG常用命令" class="headerlink" title="DEBUG常用命令"></a>DEBUG常用命令</h5><p>-r ds<br> :1000<br>-d ds:10 18             ;查看1000:10~1000:18中的内容<br>-d cs:0                 ;查看当前代码段中的指令代码<br>-d ss:0                ;查看当前栈段中的内容<br>-u cs:0                ; 以汇编指令的形式，显示当前代码段中的代码，0代码的<br>     偏移地址<br>-r ds<br>:1000<br>-a ds:0                 ;以汇编指令的形式，向从1000:0开始的内存单元中写入指<br>     令</p>
<h3 id="指令和操作符"><a href="#指令和操作符" class="headerlink" title="指令和操作符"></a>指令和操作符</h3><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><ul>
<li><p><strong>mov</strong>：传送指令</p>
</li>
<li><p><strong>add</strong>：加法指令</p>
</li>
<li><p><strong>push</strong> ax表示将寄存器ax中的数据送入栈，只能执行字操作。</p>
</li>
<li><p><strong>pop</strong> ax表示就从栈顶取出数据送入ax<br>将ax清零，可以用sub ax,ax；也可以用mov ax,0；sub ax,ax的机器码为2个字节，mov ax,0的机器码为三个字节。</p>
</li>
<li><p><strong>inc</strong> bx 该指令表示对操作数加1（常量）即bx中的内容加1</p>
</li>
<li><p><strong>dec</strong> bx 该指令表示对操作数减1（常量）即bx中的内容减1</p>
</li>
<li><p><strong>and</strong>指令：逻辑与指令，按位进行与运算。</p>
</li>
<li><p><strong>or</strong>指令：逻辑或指令，按位进行或运算。</p>
</li>
<li><p><strong>div</strong>指令：除法指令<br>&emsp;&emsp;被除数÷除数=商…余数<br>（1）除数：8位或16位，在寄存器或内存单元中<br>（2）被除数：默认放在AX或DX和AX中。<br>&emsp;&emsp;&emsp;&emsp;AX:被除数（16位）÷ 除数（8位）=  AL商 + AH余数<br>&emsp;&emsp;&emsp;&emsp;DX，AX:被除数（32位d）÷ 除数（16位）= AX商 + DX余数<br>&emsp;&emsp;&emsp;&emsp;其中DX存高位，AX存低位。<br>&emsp;&emsp;&emsp;&emsp;div reg或div 内存单元</p>
</li>
<li><p><strong>mul</strong>指令：乘法指令<br>&emsp;&emsp;乘数*乘数=积<br>&emsp;&emsp;乘数要么都是8位，要么都是16位，寄存器或内存单元中。d<br>&emsp;&emsp;8位：  AL * 8位reg或内存  = AX<br>&emsp;&emsp;16位：AX * 16位reg或内存= DX AX<br>&emsp;&emsp;其中，DX存高位，AX存低位、</p>
</li>
</ul>
<p>没有寄存器名的情况下，word ptr 指明字单元，byte ptr 指明字节单元</p>
<ul>
<li><p><strong>loop</strong>指令：循环指令。CPU执行loop指令的时候，要进行两步操作①(cx)=(cx)-1; ②判断cx中的值，不为零则转至标号出执行程序，如果为零则向下执行。<br>&emsp;&emsp;&emsp;&emsp;mov cx,循环次数<br>&emsp;&emsp;s:&emsp; 循环执行的程序段<br>&emsp;&emsp;&emsp;&emsp;loop s</p>
</li>
<li><p><strong>jmp</strong>指令：无条件转移指令<br>jmp 段地址:偏移地址 = 用指令中给出的段地址修改CS，偏移地址修改IP<br>若仅想修改IP的内容，可用“jmp 合法寄存器”的指令完成；<br>jmp ax，在含义上好似：mov IP，ax<br>jmp是无条件转移指令，可以只修改IP，也可以同时修改CS和IP。<br>“jmp short 标号”（转到标号处执行指令），这是段内短转移，它对IP的修改范围是-128~127，在汇编中对应的机器码是EBFF，FF为偏移地址,用的是补码表示。<br>“jmp short 标号”的功能为：（IP）=（IP）+ 8位位移，段内近转移<br>“jmp near ptr 标号”的功能为：（IP）=（IP）+ 16位位移，段内近转移<br>“jmp far ptr 标号”为段间转移，又称远转移。<br>“jmp word ptr 内存单元地址”段内转移<br>“jmp dword ptr 内存单元地址”段间转移<br>&emsp;&emsp;（CS）=（内存单元地址+2）<br>&emsp;&emsp;（IP）=（内存单元地址）</p>
</li>
<li><p><strong>jcxz</strong>有条件转移指令：所有有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址，修改范围是-128~127<br>&emsp;&emsp;“jcxz 标号”等于if((cx)==0) jmp short 标号;</p>
</li>
<li><p><strong>ret</strong>指令：近转移指令，进行下面两步操作<br>&emsp;&emsp;(1) (IP)=((ss)* 16+(sp))<br>&emsp;&emsp;(2) (sp)=(sp)+2<br>&emsp;&emsp;相当于：<br>&emsp;&emsp;pop IP</p>
</li>
<li><p><strong>retf</strong>指令：远转移指令，进行下面4部操作<br>&emsp;&emsp;(1) (IP)=((ss)* 16+(sp))<br>&emsp;&emsp;(2) (sp)=(sp)+2<br>&emsp;&emsp;(3) (CS)=((ss)* 16+(sp))<br>&emsp;&emsp;(4) (sp)=(sp)+2<br>&emsp;&emsp;相当于：<br>&emsp;&emsp;pop IP<br>&emsp;&emsp;pop CS</p>
</li>
<li><p><strong>call</strong>指令：<br><strong>当前IP的转移位移</strong><br>call 标号 ;将当前的IP压栈后，转到标号处执行指令。进行如下操作<br>(1)   (sp)=(sp)-2<br>&emsp;&emsp;((ss)* 16+(sp))=(IP)<br>(2)   (IP)=(IP)+ 16 位位移。<br>相当于<br>&emsp;&emsp;push IP<br>&emsp;&emsp;jmp near ptr 标号<br><strong>段间转移</strong><br>&emsp;&emsp;call far ptr 标号 ;进行如下操作<br>(1)<br>&emsp;&emsp;(sp)=(sp)-2<br>&emsp;&emsp;((ss)* 16+(sp))=(CS)<br>&emsp;&emsp;(sp)=(sp)-2<br>&emsp;&emsp;((ss)* 16+(sp))=(IP)<br>(2)<br>&emsp;&emsp;(CS)＝ 标号所在段的段地址<br>&emsp;&emsp;(IP)＝ 标号在段中的偏移地址<br>相当于<br>&emsp;&emsp;push CS<br>&emsp;&emsp;push IP<br>&emsp;&emsp;jmp far ptr 标号<br><strong>转移地址在寄存器中的call指令</strong><br>call 16位reg ;进行以下操作<br>&emsp;&emsp;(sp)=(sp)-2<br>&emsp;&emsp;((ss)* 16+(sp))=(IP)<br>&emsp;&emsp;(IP)=( 16 位reg)<br>相当于<br>&emsp;&emsp;push IP<br>&emsp;&emsp;jmp 16 位reg<br><strong>转移地址在内存中的call指令</strong><br>call word ptr 内存单元地址<br>相当于<br>&emsp;&emsp;push IP<br>&emsp;&emsp;jmp word ptr 内存单元地址<br>call dword ptr 内存单元地址<br>相当于<br>&emsp;&emsp;push CS<br>&emsp;&emsp;push IP<br>&emsp;&emsp;jmp dword ptr 内存单元地址</p>
</li>
<li><p><strong>adc</strong>指令：带进位加法指令，利用CF标志位上记录进位值<br>&emsp;&emsp;指令格式：add 操作对象1，操作对象2<br>&emsp;&emsp;功能：操作对象1 = 操作对象1 + 操作对象2 + CF<br>&emsp;&emsp;比如指令adc ax,bx 实现的功能是：(ax)=(ax)+(bx) + CF</p>
</li>
<li><p><strong>sbb</strong>指令：带借位减法指令，利用CF标志位记录借位值<br>指令格式： sb b 操作对象1 ，操作对象2<br>功能： 操作对象1 ＝操作对象1 - 操作对象2 - CF<br>比如指令sbb ax ,bx 实现的功能是： (ax)=(ax)-(bx) - CF</p>
</li>
<li><p><strong>cmp</strong>指令：比较指令<br>cmp 指令格式： cmp 操作对象1， 操作对象2<br>功能： 计算操作对象1 － 操作对象2 但并不保存结果， 仅仅根据计算结果对标志寄存器进行设置。<br>比如， 指令cmp ax ,ax, 做（ax )一(ax )的运算， 结果为0, 但并不在ax 中保存， 仅影响flag 的相关各位。指令执行后： zf=l, pf=l, sf= 0, cf= 0, of= 0。</p>
</li>
<li><p>常用的根据无符号数的比较结果进行转移的条件转移指令。<br>字母表示意义如下。e: 表示equal； ne: 表示not equal； b: 表示below； nb: 表示not below； a: 表示above； na: 表示not above</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
<th>检测的相关标志位</th>
</tr>
</thead>
<tbody><tr>
<td>je</td>
<td>等于则转移</td>
<td>zf=1</td>
</tr>
<tr>
<td>jne</td>
<td>不等于则转移</td>
<td>zf=0</td>
</tr>
<tr>
<td>jb</td>
<td>低于则转移</td>
<td>cf=1</td>
</tr>
<tr>
<td>jnb</td>
<td>不低于则转移</td>
<td>cf=0</td>
</tr>
<tr>
<td>ja</td>
<td>高于则转移</td>
<td>cf=0且zf=0</td>
</tr>
<tr>
<td>na</td>
<td>不高于则转移</td>
<td>cf=1或zf=1</td>
</tr>
</tbody></table>
<ul>
<li><strong>movesb</strong>指令：串传送指令，功能是将ds: si 指向的内存单元中的字节送入es:di 中， 然后根据标志寄存器df 位的值， 将si 和di 递增或递减。</li>
<li><strong>movesw</strong>指令：串传送指令，功能是将ds: si 指向的内存字单元中的字送入es:di 中， 然后根据标志寄存器df 位的值， 将si 和di 递增2 或递减2。</li>
<li><strong>rep</strong>指令：一般来说， movsb 和movsw 都和rep 配合使用， 格式如下：<br>rep movsb<br>作用是根据cx的值， 重复执行后面的串传送指令。</li>
<li><strong>cld</strong>指令： 将标志寄存器的df位置0，正向</li>
<li><strong>std</strong>指令： 将标志寄存器的df位置1，反向</li>
<li><strong>sti</strong>指令：设置1F= l </li>
<li><strong>cli</strong>指令：设置IF=O </li>
<li><strong>pushf</strong>和<strong>popf</strong>指令：将标志寄存器的值压栈和出栈。</li>
<li><strong>iret</strong>指令：通常和硬件自动完成的中断过程配合使用，它的功能用汇编语法描述为：<br>pop IP<br>pop CS<br>popf</li>
<li><strong>in</strong>和<strong>out</strong>指令：分别用千从端口读取数据和往端口写入数据</li>
<li><strong>shl</strong>命令：逻辑左移指令， 它的功能为：<br>&emsp;&emsp;将一个寄存器或内存单元中的数据向左移位；<br>&emsp;&emsp;将最后移出的一位写入CF 中；<br>&emsp;&emsp;最低位用0补充。<br>&emsp;&emsp;如果移动位数大千1 时， 必须将移动位数放在cl中。<br>&emsp;&emsp;将X 逻辑左移一位， 相当于执行X=X*2。<br>指令:<br>&emsp;&emsp;mov al , 01001000b<br>&emsp;&emsp;shl al, 1&emsp;&emsp;;将al 中的数据左移一位<br>执行后(al)= I00I0000b, CF=0。</li>
<li><strong>shr</strong>指令：逻辑右移指令， 它和shl所进行的操作刚好相反。</li>
</ul>
<h4 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h4><p><strong>idata</strong> 表示常量<br><strong>dup</strong> 用来进行数据重复的操作符<br><strong>db</strong> 3 dup (0)     ;定义3个字节，他们的都是0，相当于db 0,0,0<br><strong>db</strong> 字节型数据<br><strong>dw</strong> 字形数据<br><strong>dd</strong> 双字型数据<br><strong>offset</strong> 取得标号的偏移地址；offset start表示取得start的偏移地址<br><strong>nop</strong> 空指令，不执行操作，但占一个程序步骤。占一个byte，8位即ff。</p>
]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac Pro 2015 硬盘扩容升级参考</title>
    <url>/2019/04/24/Mac%20Pro%202015%E7%A1%AC%E7%9B%98%E6%89%A9%E5%AE%B9%E5%8D%87%E7%BA%A7%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>前几天升级了我的Mac Pro硬盘，也查找了一下资料，现在写下来，如果你想对你的Mac进行升级，这也许能给你一些参考。</p>
<a id="more"></a>

<h4 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h4><blockquote>
<h6 id="我的Mac信息"><a href="#我的Mac信息" class="headerlink" title="我的Mac信息"></a>我的Mac信息</h6><p>配置：Mac Pro 2015 13英寸</p>
<p>型号：A1502</p>
<p>内存：8G</p>
<p>硬盘：128G Apple SSD</p>
</blockquote>
<p>我是2015年下半年买的这款Mac，如今19年四月份，已经将近四年了，电脑一般的寿命是五年左右，超过五年的电脑，一般都有各种元器件老化的问题，要换零件才能继续使用。我这电脑坚挺了近四年，没有坏过一次。想着明年准备换台新电脑，在换电脑以前，也想让它发挥一下余热。我这款Mac的硬盘是128G，作为iOSer，Xcode的一个软件，占用将近60G左右，还不包扩各种工程文件，其他软件。所以，内存紧张的问题困扰我也有一段时间了，因此这次准备换一下硬盘，将硬盘升级到512G。</p>
<p>其实也想加一个内存条，但是这款Mac的内存条已经焊接在主板上了，增加有点难度，需要专业人员才行，因此只能作罢。</p>
<h4 id="资料整理"><a href="#资料整理" class="headerlink" title="资料整理"></a>资料整理</h4><p>硬盘的选择还是综合下价格和性能的考虑。</p>
<ul>
<li><p>最优的是原装配件的Apple SSD，厂家是三星的。512G硬盘的淘宝价格大概1800软妹币。支持双系统。</p>
</li>
<li><p>东芝XG5 M.2 PCIE NVMe M2系列固态硬盘，512G硬盘价格大概在1100软妹币。支持双系统（<a href="[https://bbs.feng.com/read-htm-tid-11795599.html](https://bbs.feng.com/read-htm-tid-11795599.html">案例</a>）。需要硬盘转接卡。</p>
</li>
<li><p>三星SM951 PCIE NVMe M2系列固态硬盘，512G硬盘大概750软妹币左右。论坛有人说不支持双系统。需要硬盘转接卡。</p>
</li>
<li><p>Intel 760P PCIE NVMe M2系列固态硬盘。512G硬盘大概600软妹币左右。论坛有人说不支持双系统。需要硬盘转接卡。</p>
</li>
<li><p>其他NVME硬盘也可以。但是尽量选择大厂硬盘，质量有所保障。</p>
</li>
</ul>
<p>我不需要安装双系统，东芝XG5，三星951和英特尔760P性能相差不大，我对三星无感，因此选择了Intel 760P。</p>
<p>因为Apple SSD硬盘卡接口和NVMe硬盘卡接口不一致，所以只能使用硬盘转接卡。英特尔760P装上硬盘转接卡后，长度和Apple SSD一样。</p>
<p>我在买硬盘转接卡的时候，看到商品详情里表明了一些可以更换硬盘的mac版本，如下：</p>
<blockquote>
<p>2013 version MacBook Pro retina A1398 A1502 (ME864 ME865 ME866 ME293 ME294)</p>
<p>2014 version MacBook Pro retina A1502 A1398 (MGX72 MGX82 MGX92 MGXA2 MGXC2)</p>
<p>2015 version MacBook Pro retina A1502 A1398(MF839 MF840 MF841 MJLU2 MJLT2 MJLQ2)</p>
<p>2013-2014 version MacBook Air A1465 A1466(MD711 MD712 MD760 MD761)</p>
<p>2015 version MacBook Air A1465 A1466(MJVM2 MJVP2 MJVE2 MJVG2)</p>
<p>2017 version MacBook Air A1466(MQD32 MQD42 MQD52 EMC3178)</p>
<p>Mac Pro ME253 MD878,iMAC A1419(Late 2013 and newer).</p>
<p>2014版Mac mini A1347</p>
<p>2013版苹果一体机iMAC A1418</p>
<p>2017版iMAC A1418</p>
<p>2013 2014 2015 1016 2017版27寸iMAC A1419</p>
</blockquote>
<h4 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h4><h6 id="1-最优方案"><a href="#1-最优方案" class="headerlink" title="1.最优方案"></a>1.最优方案</h6><ol>
<li>使用<code>TimeMachine</code>备份到新硬盘作为备份盘。备份盘可以选择机械硬盘，没有太高的要求，空间只要比电脑已使用空间大一些就行。备份盘格式为Mac os 扩展(日志式)，如果不是，可以打开磁盘工具，抹掉重新格式化一下，然后再使用<code>TimeMachine</code>备份到磁盘。</li>
<li>将新的SSD放到硬盘盒，然后连接电脑，格式化，格式为Mac os 扩展(日志式)，名字建议改为<code>Macintosh</code>,因为原系统的硬盘名字为<code>Macintosh HD</code>，其实新硬盘名字和旧的一样也行。</li>
<li>备份盘也连接电脑，重启Mac，按住option，稍等片刻，选择备份盘，然后将备份恢复到新硬盘就行了。</li>
<li>然后更换新SSD到Mac上就行了。</li>
</ol>
<p>优点：操作简单，数据不会丢失，软件不需要重装。</p>
<h6 id="2-第二方案"><a href="#2-第二方案" class="headerlink" title="2.第二方案"></a>2.第二方案</h6><ol>
<li><p>下载macOS Mojave或macOS Sierra安装包（下面有下载地址），打开dmg镜像，将安装程序，拖到应用程序文件夹，准备一个大于安装包大小的U盘，16就足够了。格式化为Mac os 扩展(日志式)，然后看这个教程<a href="https://www.iplaysoft.com/macos-usb-install-drive.html">https://www.iplaysoft.com/macos-usb-install-drive.html</a>，将优盘制作成启动盘，教程最下面，也有安装办法，只不过，安装的话，要安装到新硬盘上。</p>
</li>
<li><p>将新的SSD放到硬盘盒，然后连接电脑，格式化，格式为Mac os 扩展(日志式)，名字建议改为<code>Macintosh</code>,因为原系统的硬盘名字为<code>Macintosh HD</code>，其实新硬盘名字和旧的一样也行。</p>
</li>
<li><p>将启动U盘和新SSD一同连接电脑，重启Mac，按住option，稍等片刻，等到启动U盘和新SSD都出现后，选择启动U盘，将系统安装到新SSD上。</p>
</li>
<li><p>然后更换新SSD到Mac上就行了。</p>
</li>
</ol>
<p>优点：启动优盘制作后，以后可以一直用。新系统全新，相当于换了一个新电脑。缺点就是所有东西都要重新安装。</p>
<h6 id="3-第三方案"><a href="#3-第三方案" class="headerlink" title="3.第三方案"></a>3.第三方案</h6><ol>
<li><p>将新的SSD放到硬盘盒，然后连接电脑，格式化，格式为Mac os 扩展(日志式)，名字建议改为<code>Macintosh</code>,因为原系统的硬盘名字为<code>Macintosh HD</code>，其实新硬盘名字和旧的一样也行。</p>
</li>
<li><p>下载macOS Mojave或macOS Sierra安装包（下面有下载地址），打开dmg镜像，直接打开安装程序，启动安装，安装到新SSD。</p>
</li>
<li><p>然后更换新SSD到Mac上就行了。</p>
</li>
</ol>
<p>优点：操作简单，一次性。缺点和第二方案一样。</p>
<p>安装成功之后，可以首先升级一下系统到最新版本。</p>
<p>我选择的是第三方案，强烈建议安装前，使用备份盘，备份一下原电脑。谁知道我为啥没有备份，安装之前用的所有程序都花了我一天时间。</p>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><h6 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h6><p>我的更换的过程主要是参考网友<code>late哥哥</code>的<a href="https://blog.csdn.net/qq_28029345/article/details/85262542">MacBook Pro 2015 mid ssd存储升级扩容需求以及解决方案</a></p>
<p>Mac OS最近几年的版本，都不支持安装包的直接下载，而是直接调起App Store，因此只能在网上找资源了，据说可以从<code>MAS</code>下载系统安装包。这是我找到的一个Install macOS Mojave 10.14的下载地址，直接打开安装，或者制作启动U盘安装，都可以。</p>
<p>Install macOS Mojave 10.14.dmg软件下载<a href="https://pan.baidu.com/s/1Tz86rXPTLjaHid1tsPx_MA">https://pan.baidu.com/s/1Tz86rXPTLjaHid1tsPx_MA</a>密码<code>d5n2</code></p>
<h6 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h6><ol>
<li><p>硬盘。选择合适的硬盘，512G或1T SSD硬盘卡。</p>
</li>
<li><p>拆机工具。如果只更换硬盘的话，只需要准备5星和6星的螺丝刀。五星螺丝刀用来拆Mac后壳，六星螺丝刀用来拆硬盘。<strong>注意：</strong>拆卸时，螺丝刀顺时针是拧紧，逆时针是拆下。切记不可太过用力，容易损坏螺丝。</p>
</li>
<li><p>Mac SSD或NVMe硬盘盒。用硬盘盒的目的就是在更换硬盘之前，将mac os安装到硬盘上，这样，换过硬盘就直接能使用了。</p>
</li>
<li><p>NVMe M.2转mac ssd转接卡。如果你买的是Mac SSD就无需转接卡了。转接卡淘宝有卖。</p>
</li>
<li><p>静电手环。非必须。</p>
</li>
</ol>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li><p>根据所选方案，将新系统安装到新硬盘。</p>
</li>
<li><p>拆卸Mac。断开电源，关机电脑。有静电手环的可以带上。使用螺丝刀拆卸Mac后壳，一般是五星螺丝刀，注意，因为Mac后壳的螺丝钉并不是全都一样，最好对每个位置编个号，然后各个位置的螺丝钉放到编号位置上，这样后壳安装时，还可以使用之前位置的螺丝钉，这样不会搞错。</p>
</li>
<li><p>螺丝钉拆除后，后壳会有活的卡扣卡着，稍微使点劲儿，就可以把Mac后壳掰下来，不用怕掰坏。</p>
</li>
<li><p>更换硬盘。使用螺丝刀，这时应该是六星螺丝刀，拆掉螺丝钉。然后，小心翼翼，拔出原装硬盘，然后将安装好系统的新硬盘，安装到电脑上。这里我找到一个<a href="https://cloud.video.taobao.com/play/u/2551849822/p/2/e/6/t/1/221280457504.mp4?appKey=7596">更换视频</a>，可以观看一下。</p>
</li>
<li><p>更换好硬盘后，先合上后盖，开机，确认硬盘可用后，再关机，安装螺丝钉。如果开机不可用，换回原装硬盘，合上后壳，开机，再次尝试其他方法。</p>
</li>
</ol>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><h6 id="1-重新启动加载或休眠问题"><a href="#1-重新启动加载或休眠问题" class="headerlink" title="1.重新启动加载或休眠问题"></a>1.重新启动加载或休眠问题</h6><p>如果遇到翻盖启动时，重新启动加载或休眠问题，可以试试重置了smc或nvram。</p>
<p>重置smc：关机，按下键盘左侧的shift + control +  option，然后同时按下电源按钮，按住10秒钟，松开所有案件，然后重启。</p>
<p>nvram（pram）：将mac关机，然后按下 option + command + p + r ，按住大约20秒松开，期间大致会重启两次，然后松开。</p>
<h6 id="2-安装系统后，升级到最新版本一直报错，失败的问题"><a href="#2-安装系统后，升级到最新版本一直报错，失败的问题" class="headerlink" title="2.安装系统后，升级到最新版本一直报错，失败的问题"></a>2.安装系统后，升级到最新版本一直报错，失败的问题</h6><p>如果在升级到最新版本时一直报错，导致无法升级。请按照以下指示，再次重装系统试试。</p>
<ol>
<li><p>在 Mac 上，选取苹果菜单<code>重新启动</code>。</p>
</li>
<li><p>在 Mac 重新启动时立即执行以下操作：</p>
<p>从电脑上的内建恢复磁盘中重新安装 macOS：*按住 Command-R 直到“实用工具”窗口出现。</p>
<p>此选项将重新安装储存在您电脑内建恢复磁盘中的 macOS 版本以及您已安装的任何更新。</p>
</li>
<li><p>选择“重新安装 macOS”，然后点按“继续”。</p>
</li>
<li><p>请按照屏幕指示进行操作。在您选择磁盘的面板中，选择您当前的 macOS 磁盘。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Dart ...展开操作符</title>
    <url>/2023/08/08/Dart-%E5%B1%95%E5%BC%80%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
    <content><![CDATA[<p>Dart支持展开操作符(<strong>spread operator</strong>)<code>...</code>和空感展开操作符(<strong>null-aware spread operator</strong>)<code>...?</code>。</p>
<p>展开操作符支持所有的集合(Collections)类型，包括Set，List，Map。</p>
<h5 id="展开操作符-spread-operator"><a href="#展开操作符-spread-operator" class="headerlink" title="展开操作符(spread operator)"></a>展开操作符(<strong>spread operator</strong>)</h5><p>展开操作符<code>...</code>可以将一个列表的所有值，插入到另一个列表中。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> list2 = [<span class="number">0</span>, ...list];</span><br><span class="line"><span class="keyword">assert</span>(list2.length == <span class="number">4</span>);</span><br><span class="line"><span class="comment">// list2 = [0, 1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<h5 id="空感展开操作符-null-aware-spread-operator"><a href="#空感展开操作符-null-aware-spread-operator" class="headerlink" title="空感展开操作符(null-aware spread operator)"></a>空感展开操作符(<strong>null-aware spread operator</strong>)</h5><p>如果展开操作符右边的表达式可能为空，为了避免程序出问题可以使用空感展开操作符(<strong>null-aware spread operator</strong>)<code>...?</code>。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt;? list;</span><br><span class="line"><span class="keyword">var</span> list2 = [<span class="number">0</span>, ...?list];</span><br><span class="line"><span class="keyword">assert</span>(list2.length == <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac电脑Safari浏览器上禁止百度广告</title>
    <url>/2020/05/29/Mac%E7%94%B5%E8%84%91Safari%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8A%E7%A6%81%E6%AD%A2%E7%99%BE%E5%BA%A6%E5%B9%BF%E5%91%8A/</url>
    <content><![CDATA[<h4 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h4><p>我是一个Chrome浏览器用户，用Chrome浏览器进行百度搜索时，我用到了一个插件<a href="https://github.com/unclehking/bdAdfinisher">https://github.com/unclehking/bdAdfinisher</a>，这个插件可以过滤掉百度搜索结果的广告，实现无广告浏览，它让每个搜索结果页都很干净。这个插件几乎是我司程序员的Chrome浏览器标配插件。</p>
<a id="more"></a>

<p>但因为我用的是Mac电脑，难不免也会用到Safari浏览器。我遍寻GitHub和AppStore，也没找到一个可以禁止Safari浏览器百度广告的软件，恰好上段时间，我研究了一下Safari浏览器插件的写法，于是便产生了写一款Safari浏览器上禁止百度广告插件的想法。</p>
<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>然后就真的写成了。</p>
<p>地址：<a href="https://github.com/lengain/BanbdAdForSafari">https://github.com/lengain/BanbdAdForSafari</a></p>
<p>下载：<a href="https://github.com/lengain/BanbdAdForSafari/releases/download/1.0/BanBdAd.dmg">BanBdAd.dmg</a></p>
<p>图文教程：<a href="https://github.com/lengain/BanbdAdForSafari/blob/master/Tutorial.md">https://github.com/lengain/BanbdAdForSafari/blob/master/Tutorial.md</a></p>
<h4 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h4><p>写的过程中，借鉴了<a href="https://github.com/unclehking">unclehking</a>的chorme浏览器插件的一些代码，也和他沟通了一些关于百度的法律问题，向他的无私帮助致谢。</p>
<h4 id="以后"><a href="#以后" class="headerlink" title="以后"></a>以后</h4><p>禁止谷歌广告，掘金广告，知乎广告……？</p>
]]></content>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>Ruby方法中的!和?</title>
    <url>/2023/12/11/Ruby%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84!%E5%92%8C?/</url>
    <content><![CDATA[<h5 id="方法名后缀为”-”的方法"><a href="#方法名后缀为”-”的方法" class="headerlink" title="方法名后缀为”!”的方法"></a>方法名后缀为”!”的方法</h5><p>在Ruby中，方法名后缀为”!”的方法通常表示该方法会修改调用它的对象。这种约定起源于Smalltalk语言，在Ruby中广泛使用。</p>
<p>当一个方法后面带有”!”符号时，这个方法通常会修改调用它的对象的状态。例如，如果我们对一个数组调用<code>sort!</code>方法，这个方法会对数组进行排序，并返回排序后的数组，而原始数组将被修改。</p>
<a id="more"></a>

<p>下面是一个例子：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">rubynumbers = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">sorted_numbers = numbers.sort! </span><br><span class="line"><span class="comment"># 修改原始数组，并返回排序后的数组  </span></span><br><span class="line"><span class="comment"># puts numbers </span></span><br><span class="line"><span class="comment"># 输出: [1, 2, 3]  </span></span><br><span class="line"><span class="comment"># puts sorted_numbers </span></span><br><span class="line"><span class="comment"># 输出: [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>sort!</code>方法修改了原始数组<code>numbers</code>的状态，并返回了排序后的数组。</p>
<p>需要注意的是，有些方法同时有带”!”和不带”!”的版本。例如，<code>sort</code>方法不会修改原始数组，而是返回一个新的排序后的数组。因此，我们需要仔细查看方法的文档来了解它们的行为。</p>
<h5 id="方法名后缀为”-”的方法-1"><a href="#方法名后缀为”-”的方法-1" class="headerlink" title="方法名后缀为”?”的方法"></a>方法名后缀为”?”的方法</h5><p>在Ruby中，以”?”结尾的方法通常表示该方法返回一个布尔值（true或false）。这种约定使得代码更加可读和易于理解。</p>
<p>例如，Ruby中有很多方法以”?”结尾，如<code>nil?</code>、<code>empty?</code>、<code>blank?</code>等。这些方法通常用于条件判断，根据给定的条件返回true或false。</p>
<p>以下是一些示例：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用nil?方法判断变量是否为nil  </span></span><br><span class="line"><span class="keyword">if</span> my_variable.<span class="literal">nil</span>?    </span><br><span class="line">    puts <span class="string">&quot;my_variable is nil&quot;</span>  </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    puts <span class="string">&quot;my_variable is not nil&quot;</span></span><br><span class="line"><span class="keyword">end</span>    </span><br><span class="line"><span class="comment"># 使用empty?方法判断字符串是否为空  </span></span><br><span class="line"><span class="keyword">if</span> my_string.empty?</span><br><span class="line">    puts <span class="string">&quot;my_string is empty&quot;</span>  </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    puts <span class="string">&quot;my_string is not empty&quot;</span>  </span><br><span class="line"><span class="keyword">end</span>    </span><br><span class="line"><span class="comment"># 使用blank?方法判断字符串是否为空白（只包含空格、制表符等空白字符）</span></span><br><span class="line"><span class="keyword">if</span> my_string.blank?</span><br><span class="line">    puts <span class="string">&quot;my_string is blank&quot;</span>  </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    puts <span class="string">&quot;my_string is not blank&quot;</span>  </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>在这些示例中，通过调用以”?”结尾的方法，我们可以根据条件判断得到相应的结果。这些方法通常用于控制程序流程，根据条件执行相应的操作。</p>
<h5 id="反引号"><a href="#反引号" class="headerlink" title="反引号"></a>反引号</h5><p>在Ruby中，反引号用于执行shell命令，并将执行结果作为字符串返回。以下是反引号的使用方法：</p>
<ol>
<li>反引号包围一个shell命令，Ruby会执行该命令，并将执行结果作为字符串返回。</li>
<li>使用<code>puts</code>方法打印该变量的值。</li>
</ol>
<p>例如：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">output=<span class="string">`ls -l`</span>  </span><br><span class="line">puts output</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>ls -l</code>命令会在shell中执行，并返回结果。然后，将结果赋值给变量output，并使用puts方法打印该变量的值。</p>
]]></content>
      <tags>
        <tag>Ruby</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS Category源码探究</title>
    <url>/2020/11/19/iOS-Category%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/</url>
    <content><![CDATA[<p>Objective-C的Category特性，使的开发者在处理某些问题时，简单而又方便。理解Category的源码，对OC编程的理解会有很大的帮助。</p>
<p>Category的处理源码在libobjc.A.dylib中，苹果已经<a href="https://opensource.apple.com/tarballs/objc4/">开源</a>，但是下载后直接使用Xcode编译，会报很多错误。网上有很多帖子，介绍如何解决libobjc编译错误，这里就不介绍了。在github上有个开源项目<a href="https://github.com/xdxu1126/objc4">objc4</a>，提供了可编译版本的objc工程，可按需索取。目前苹果刚发布macOS Big Sur 11.0.1，适配该系统的Objc还没有开源，<code>objc4</code>在这个系统上会有一点错误，不过不影响阅读，各个函数，变量定义之间的跳转也没有问题。</p>
<a id="more"></a>

<h3 id="category-t"><a href="#category-t" class="headerlink" title="category_t"></a>category_t</h3><p> 首先从源码层面来看一下Category有什么样的结构。</p>
<p>使用clang可以将Category的.m文件编译为.cpp文件，文件中有OC对Category的处理。</p>
<p>Category在objc中的结构体为<code>category_t</code>，该结构体中有实例方法，类方法，协议，属性，类属性等成员。Category的结构体决定了我们在使用Category时，可以为Category添加哪些代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;<span class="comment">//类名</span></span><br><span class="line">    <span class="keyword">classref_t</span> cls;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">instanceMethods</span>;</span><span class="comment">//实例方法</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">classMethods</span>;</span><span class="comment">//类方法</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span><span class="comment">//协议</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *<span class="title">instanceProperties</span>;</span><span class="comment">//属性</span></span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *_<span class="title">classProperties</span>;</span><span class="comment">//类属性</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">method_list_t</span> *<span class="title">methodsForMeta</span><span class="params">(<span class="keyword">bool</span> isMeta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> classMethods;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> instanceMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">property_list_t</span> *<span class="title">propertiesForMeta</span><span class="params">(<span class="keyword">bool</span> isMeta, struct header_info *hi)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protocol_list_t</span> *<span class="title">protocolsForMeta</span><span class="params">(<span class="keyword">bool</span> isMeta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> protocols;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>程序初始化时，libobjc会将每个Category中的添加的属性，方法等合并到当前类的属性列表方法列表中。</p>
<h3 id="从入口到详情"><a href="#从入口到详情" class="headerlink" title="从入口到详情"></a>从入口到详情</h3><p>以下的代码，会从一个个函数调用帮助我们认识Objc对Category的处理。</p>
<p>objc-os.mm中的_objc_init函数是objc初始化的方法。从_objc_init出发，可以找到加载Category的方法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// _objc_init objc-os.mm</span></span><br><span class="line"><span class="comment">// Bootstrap initialization. Registers our image notifier with dyld.</span></span><br><span class="line"><span class="comment">// Called by libSystem BEFORE library initialization tim</span></span><br><span class="line"><span class="keyword">void</span> _objc_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fixme defer initialization until an objc-using image is found?</span></span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    static_init();</span><br><span class="line">    runtime_init();</span><br><span class="line">    exception_init();</span><br><span class="line">    cache_init();</span><br><span class="line">    _imp_implementationWithBlock_init();</span><br><span class="line">    <span class="comment">//_dyld_objc_notify_register注册三个回调函数，</span></span><br><span class="line">    <span class="comment">// map_images：dyld将image加载到内存时调用 </span></span><br><span class="line">    <span class="comment">// load_images：dyld初始化image，load方法都在此时调用</span></span><br><span class="line">    <span class="comment">// unmap_image：将image移除内存时调用</span></span><br><span class="line">    <span class="comment">// map_images这个方法，用来处理被dyld映射过来的镜像，注册后就会被调用</span></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    didCallDyldNotifyRegister = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map_images objc-runtime-new.mm</span></span><br><span class="line"><span class="comment">// Process the given images which are being mapped in by dyld.</span></span><br><span class="line"><span class="comment">// Calls ABI-agnostic code after taking ABI-specific locks.</span></span><br><span class="line"><span class="comment">// Locking: write-locks runtimeLock</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">map_images(<span class="keyword">unsigned</span> count, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> paths[],</span><br><span class="line">           <span class="keyword">const</span> struct mach_header * <span class="keyword">const</span> mhdrs[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">    <span class="comment">//map_images_nolock方法就是map_images的内部实现</span></span><br><span class="line">    <span class="keyword">return</span> map_images_nolock(count, paths, mhdrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//map_images_nolock objc-os.mm</span></span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">map_images_nolock(<span class="keyword">unsigned</span> mhCount, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> mhPaths[],</span><br><span class="line">                  <span class="keyword">const</span> struct mach_header * <span class="keyword">const</span> mhdrs[])</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Find all images with Objective-C metadata.</span></span><br><span class="line">    <span class="comment">//找到元数据中所有的镜像数量</span></span><br><span class="line">    hCount = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (hCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//读取镜像</span></span><br><span class="line">        _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// _read_images objc-runtime-new.mm</span></span><br><span class="line"><span class="comment">// Perform initial processing of the headers in the linked </span></span><br><span class="line"><span class="comment">// list beginning with headerList. </span></span><br><span class="line"><span class="comment">// Called by: map_images_nolock</span></span><br><span class="line"><span class="comment">// Locking: runtimeLock acquired by map_images</span></span><br><span class="line"><span class="comment">// _read_images中执行了大量的操作，比如加载类，cagetory，协议等信息到内存中</span></span><br><span class="line"><span class="keyword">void</span> _read_images(header_info **hList, <span class="keyword">uint32_t</span> hCount, <span class="keyword">int</span> totalClasses, <span class="keyword">int</span> unoptimizedTotalClasses) &#123;</span><br><span class="line">    <span class="comment">//定义header_info，读取hList中的镜像头信息</span></span><br><span class="line">    <span class="comment">//header_info中存着镜像的信息</span></span><br><span class="line">    <span class="keyword">uint32_t</span> hIndex;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Discover categories. Only do this after the initial category</span></span><br><span class="line">    <span class="comment">// attachment has been done. For categories present at startup,</span></span><br><span class="line">    <span class="comment">// discovery is deferred until the first load_images call after</span></span><br><span class="line">    <span class="comment">// the call to _dyld_objc_notify_register completes. rdar://problem/53119145</span></span><br><span class="line">    <span class="keyword">if</span> (didInitialAttachCategories) &#123;</span><br><span class="line">        <span class="keyword">for</span> (hIndex = <span class="number">0</span>;hIndex &lt; hCount &amp;&amp; (hi = hList[hIndex]); hIndex++) &#123;</span><br><span class="line">            <span class="comment">//加载分类信息</span></span><br><span class="line">            load_categories_nolock(hi);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">load_categories_nolock</span><span class="params">(header_info *hi)</span> </span>&#123;</span><br><span class="line">     ....</span><br><span class="line">                <span class="comment">// First, register the category with its target class.</span></span><br><span class="line">                <span class="comment">// Then, rebuild the class&#x27;s method lists (etc) if</span></span><br><span class="line">                <span class="comment">// the class is realized.</span></span><br><span class="line">                <span class="keyword">if</span> (cat-&gt;instanceMethods ||  cat-&gt;protocols</span><br><span class="line">                    ||  cat-&gt;instanceProperties)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cls-&gt;isRealized()) &#123;</span><br><span class="line">                        <span class="comment">//添加Categories</span></span><br><span class="line">                        attachCategories(cls, &amp;lc, <span class="number">1</span>, ATTACH_EXISTING);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        objc::unattachedCategories.addForClass(lc, cls);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cat-&gt;classMethods  ||  cat-&gt;protocols</span><br><span class="line">                    ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cls-&gt;ISA()-&gt;isRealized()) &#123;</span><br><span class="line">                        attachCategories(cls-&gt;ISA(), &amp;lc, <span class="number">1</span>, ATTACH_EXISTING | ATTACH_METACLASS);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        objc::unattachedCategories.addForClass(lc, cls-&gt;ISA());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Attach method lists and properties and protocols from categories to a class.</span></span><br><span class="line"><span class="comment">// Assumes the categories in cats are all loaded and sorted by load order, </span></span><br><span class="line"><span class="comment">// oldest categories first.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">attachCategories(Class cls, <span class="keyword">const</span> <span class="keyword">locstamped_category_t</span> *cats_list, <span class="keyword">uint32_t</span> cats_count,</span><br><span class="line">                 <span class="keyword">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(PrintReplacedMethods)) &#123;</span><br><span class="line">        printReplacements(cls, cats_list, cats_count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(PrintConnecting)) &#123;</span><br><span class="line">        _objc_inform(<span class="string">&quot;CLASS: attaching %d categories to%s class &#x27;%s&#x27;%s&quot;</span>,</span><br><span class="line">                     cats_count, (flags &amp; ATTACH_EXISTING) ? <span class="string">&quot; existing&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">                     cls-&gt;nameForLogging(), (flags &amp; ATTACH_METACLASS) ? <span class="string">&quot; (meta)&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Only a few classes have more than 64 categories during launch.</span></span><br><span class="line"><span class="comment">     * This uses a little stack, and avoids malloc.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Categories must be added in the proper order, which is back</span></span><br><span class="line"><span class="comment">     * to front. To do that with the chunking, we iterate cats_list</span></span><br><span class="line"><span class="comment">     * from front to back, build up the local buffers backwards,</span></span><br><span class="line"><span class="comment">     * and call attachLists on the chunks. attachLists prepends the</span></span><br><span class="line"><span class="comment">     * lists, so the final result is in the expected order.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">uint32_t</span> ATTACH_BUFSIZ = <span class="number">64</span>;</span><br><span class="line">    <span class="keyword">method_list_t</span>   *mlists[ATTACH_BUFSIZ];</span><br><span class="line">    <span class="keyword">property_list_t</span> *proplists[ATTACH_BUFSIZ];</span><br><span class="line">    <span class="keyword">protocol_list_t</span> *protolists[ATTACH_BUFSIZ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> mcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> propcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> protocount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> fromBundle = NO;</span><br><span class="line">    <span class="keyword">bool</span> isMeta = (flags &amp; ATTACH_METACLASS);</span><br><span class="line">    <span class="comment">//auto是C++的语法，表示类型根据自动代码自动推断。</span></span><br><span class="line">    <span class="comment">//cls-&gt;data()-&gt;extAllocIfNeeded()返回的就是class_rw_ext_t *类型</span></span><br><span class="line">    <span class="comment">//class_rw_ext_t中存有方法，属性，协议等信息。</span></span><br><span class="line">    <span class="keyword">auto</span> rwe = cls-&gt;data()-&gt;extAllocIfNeeded();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; cats_count; i++) &#123;</span><br><span class="line">        <span class="comment">//entry:locstamped_category_t</span></span><br><span class="line">        <span class="keyword">auto</span>&amp; entry = cats_list[i];</span><br><span class="line">        <span class="comment">//取出分类中的方法</span></span><br><span class="line">        <span class="keyword">method_list_t</span> *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">        <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mcount == ATTACH_BUFSIZ) &#123;</span><br><span class="line">                prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</span><br><span class="line">                rwe-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">                mcount = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//ATTACH_BUFSIZ=64</span></span><br><span class="line">            <span class="comment">//这句话等于mlists[64- ++mcount] = mlist;</span></span><br><span class="line">            <span class="comment">//倒序合并分类到mlists，后面会将mlists再合并到类的方法列表中</span></span><br><span class="line">            mlists[ATTACH_BUFSIZ - ++mcount] = mlist;</span><br><span class="line">            fromBundle |= entry.hi-&gt;isBundle();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">property_list_t</span> *proplist =</span><br><span class="line">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</span><br><span class="line">        <span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (propcount == ATTACH_BUFSIZ) &#123;</span><br><span class="line">                rwe-&gt;properties.attachLists(proplists, propcount);</span><br><span class="line">                propcount = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            proplists[ATTACH_BUFSIZ - ++propcount] = proplist;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protocol_list_t</span> *protolist = entry.cat-&gt;protocolsForMeta(isMeta);</span><br><span class="line">        <span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (protocount == ATTACH_BUFSIZ) &#123;</span><br><span class="line">                rwe-&gt;protocols.attachLists(protolists, protocount);</span><br><span class="line">                protocount = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            protolists[ATTACH_BUFSIZ - ++protocount] = protolist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mcount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        prepareMethodLists(cls, mlists + ATTACH_BUFSIZ - mcount, mcount, NO, fromBundle);</span><br><span class="line">        <span class="comment">//将mlists合并到rwe-&gt;methods</span></span><br><span class="line">        rwe-&gt;methods.attachLists(mlists + ATTACH_BUFSIZ - mcount, mcount);</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; ATTACH_EXISTING) flushCaches(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rwe-&gt;properties.attachLists(proplists + ATTACH_BUFSIZ - propcount, propcount);</span><br><span class="line"></span><br><span class="line">    rwe-&gt;protocols.attachLists(protolists + ATTACH_BUFSIZ - protocount, protocount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//attachLists objc-runtime-new.mm</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attachLists</span><span class="params">(List* <span class="keyword">const</span> * addedLists, <span class="keyword">uint32_t</span> addedCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (addedCount == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">            <span class="comment">// many lists -&gt; many lists</span></span><br><span class="line">            <span class="keyword">uint32_t</span> oldCount = <span class="built_in">array</span>()-&gt;count;</span><br><span class="line">            <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">            <span class="comment">//realloc memmove memcpy三个是C语言方法。</span></span><br><span class="line">            <span class="comment">//realloc 先判断当前的指针是否有足够的连续空间，如果有，</span></span><br><span class="line">            <span class="comment">//扩大mem_address指向的地址，并且将mem_address返回，</span></span><br><span class="line">            <span class="comment">//如果空间不够，先按照newsize指定的大小分配空间，将原有</span></span><br><span class="line">            <span class="comment">//数据从头到尾拷贝到新分配的内存区域，而后释放原来mem_address</span></span><br><span class="line">            <span class="comment">//所指内存区域（注意：原来指针是自动释放，不需要使用free），</span></span><br><span class="line">            <span class="comment">//同时返回新分配的内存区域的首地址。即重新分配存储器块的地址。</span></span><br><span class="line">            <span class="comment">//memmove 用于拷贝字节，如果目标区域和源区域有重叠的话，</span></span><br><span class="line">            <span class="comment">//memmove能够保证源串在被覆盖之前将重叠区域的字节拷贝到</span></span><br><span class="line">            <span class="comment">//目标区域中，但复制后源内容会被更改。但是当目标区域与源区域</span></span><br><span class="line">            <span class="comment">//没有重叠则和memcpy函数功能相同。</span></span><br><span class="line">            <span class="comment">//memcpy 指的是C和C++使用的内存拷贝函数，函数原型为</span></span><br><span class="line">            <span class="comment">//void *memcpy(void *destin, void *source, unsigned n)；</span></span><br><span class="line">            <span class="comment">//函数的功能是从源内存地址的起始位置开始拷贝若干个字节到目标内存</span></span><br><span class="line">            <span class="comment">//地址中，即从源source中拷贝n个字节到目标destin中。</span></span><br><span class="line">            <span class="comment">//增加数组的长度</span></span><br><span class="line">            setArray((<span class="keyword">array_t</span> *)<span class="built_in">realloc</span>(<span class="built_in">array</span>(), <span class="keyword">array_t</span>::byteSize(newCount)));</span><br><span class="line">            <span class="comment">//重设新数组的长度</span></span><br><span class="line">            <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">            <span class="comment">//将array()-&gt;lists 复制到 array()-&gt;lists + addedCount，即先将 array()-&gt;lists 后移，空出位置来存放addedLists</span></span><br><span class="line">            memmove(<span class="built_in">array</span>()-&gt;lists + addedCount, <span class="built_in">array</span>()-&gt;lists, </span><br><span class="line">                    oldCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">            <span class="comment">//将 addedLists 复制到 array()-&gt;lists</span></span><br><span class="line">            <span class="comment">//由此可见分类中的方法会被添加到原有方法的前面。在方法查询时，分类中的方法会先被查到并返回。如果分类中定义了和原类中一样的方法，就会只执行分类中的方法。</span></span><br><span class="line">            <span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, </span><br><span class="line">                   addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">list</span>  &amp;&amp;  addedCount == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 0 lists -&gt; 1 list</span></span><br><span class="line">            <span class="built_in">list</span> = addedLists[<span class="number">0</span>];</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 1 list -&gt; many lists</span></span><br><span class="line">            List* oldList = <span class="built_in">list</span>;</span><br><span class="line">            <span class="keyword">uint32_t</span> oldCount = oldList ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">            setArray((<span class="keyword">array_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">array_t</span>::byteSize(newCount)));</span><br><span class="line">            <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">            <span class="keyword">if</span> (oldList) <span class="built_in">array</span>()-&gt;lists[addedCount] = oldList;</span><br><span class="line">            <span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, </span><br><span class="line">                   addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>以上就是Category在运行时被加载的过程。整理一下流程：</p>
<ol>
<li><p><code>_objc_init()</code></p>
</li>
<li><p><code>map_images(...)</code></p>
</li>
<li><p><code>map_images_nolock(...)</code></p>
</li>
<li><p><code>_read_images(...)</code></p>
</li>
<li><p><code>load_categories_nolock()</code></p>
</li>
<li><p><code>attachCategories(...)</code></p>
</li>
</ol>
<p>以上。</p>
]]></content>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Xcode警告汇总分析</title>
    <url>/2019/01/05/Xcode%E8%AD%A6%E5%91%8A%E6%B1%87%E6%80%BB%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>Xcode工程警告在我们工作中经常遇到，却又常常忽略的。正确的处理Xcode警告可以使得我们开发出优秀的程序。而在实际开发过程中，我们有可能因为项目紧，开发周期短而忽视掉一些警告。本文旨在分析Xcode工程中的各种警告，并根据警告部分的程序对工程影响程度的大小，进行排序，然后提醒开发者，及时处理对工程影响较大的警告。</p>
<a id="more"></a>

<p>我会按照10分（严重）到1分（可忽略）的顺序，对各种警告进行打分。分数说明：严重（10）、较严重（8）、建议处理（5）、一般（3）、可忽略（1）。其中&gt;=5分的，建议立即处理，其他可稍后处理，但是一定要去处理，除非该处警告经观察后，无需处理。</p>
<p>我的Xcode版本：<code>Version 10.1 (10B61)</code></p>
<p>这里从<code>Run/Build</code>时和 <code>Analyze</code>时两种情况来分析。</p>
<h4 id="Xcode-Run-Build警告"><a href="#Xcode-Run-Build警告" class="headerlink" title="Xcode Run/Build警告"></a>Xcode Run/Build警告</h4><h5 id="Dependency-Analysis-Warning（依赖分析警告）"><a href="#Dependency-Analysis-Warning（依赖分析警告）" class="headerlink" title="Dependency Analysis Warning（依赖分析警告）"></a>Dependency Analysis Warning（依赖分析警告）</h5><p>通常是工程配置不正确引起。</p>
<p>例如：Mutiple build commands for output file xxx。解决方法：通常是由于重复引用文件导致。在<code>Build Phases</code> <code>Copy Bundle Resources</code>中删除重复文件就可以了。</p>
<p>分析：本警告在Xcode10之前，无需处理，但是，Xcode10之后，会报错，导致无法运行程序，虽然可以切换Xcode 的Build System为<code>Legncy Build System</code>，但这其实是避开问题不去解决的鸵鸟心态。因此这里定此警告为6分，建议碰到即处理。</p>
<h5 id="Documentation-Issue（文档问题）"><a href="#Documentation-Issue（文档问题）" class="headerlink" title="Documentation Issue（文档问题）"></a>Documentation Issue（文档问题）</h5><p>通常是方法的文档里，方法的参数未写文档或文档的参数与方法的参数不匹配引起的问题。</p>
<p>分析：文档警告对要求比较高的程序员，可能不能忍受。看见的话还是会改一下，但是有些参数真的是没什么好写的。这里定为2分。</p>
<p>扩展：工程里可以禁用Documentation Issue，参照这里<a href="https://stackoverflow.com/questions/24453188/disable-documentation-comments-warning-for-selected-files">Disable “Documentation Comments” warning for selected files</a></p>
<h5 id="Lexical-or-Preprocessor-Issue（词汇或预处理程序问题）"><a href="#Lexical-or-Preprocessor-Issue（词汇或预处理程序问题）" class="headerlink" title="Lexical or Preprocessor Issue（词汇或预处理程序问题）"></a>Lexical or Preprocessor Issue（词汇或预处理程序问题）</h5><p>通常是宏重复定义，引用文件名大小写不匹配等警告。</p>
<p>例如：</p>
<p>non-portable path to file .h,specified path differs in case from file name on disk 解决方法：检查文件名，修改正确</p>
<p>‘xxx’ macro redefined 解决方法：重新定义新的宏或删除宏</p>
<p>分析：当宏重复定义，但是值不一样时，有可能会造成错误。因此词汇或预处理程序问题建议碰到后，立即修改。这里定为5分。</p>
<h5 id="Semantic-Issue（语义问题）"><a href="#Semantic-Issue（语义问题）" class="headerlink" title="Semantic Issue（语义问题）"></a>Semantic Issue（语义问题）</h5><p>这种问题在工程中经常见到，通常情况并不会影响程序的运行，通常是由于程序员的编码习惯所致，程序员在注意到这个问题后，应尽量避免这种问题。而且代码里一堆警告，也不美观。</p>
<p>例如：</p>
<p>Block implicitly retains ‘self’; explicitly mention ‘self’ to indicate this is intended behavior 解决方法：指定全局变量为<code>self.iVar</code>或<code>self-&gt;_iVar</code>，同时，也可以禁掉这个提示，参照<a href="https://stackoverflow.com/questions/21577711/block-implicitly-retains-self-explicitly-mention-self-to-indicate-this-is-i">这里</a>。</p>
<p>Method definition for ‘custom method’ not found 解决方法：删除或定义方法</p>
<p>Incompatible pointer types initializing ‘xxx’ with an expression of type ‘yyy’ Format String Issue 解决方法：类型强转</p>
<p>Class ‘xxx’ does not conform to protocol ‘yyy’ 解决方法：实现协议中的方法或声明协议中的方法为<code>@optional</code>。</p>
<p>等。</p>
<p>分析：语义问题很常见，通常不会引起什么错误。这里定为4分。在了解是那种警告并且确认不改不会造成问题之后可以放任不管。</p>
<h5 id="User-Defined-Issue（用户自定义问题）"><a href="#User-Defined-Issue（用户自定义问题）" class="headerlink" title="User-Defined Issue（用户自定义问题）"></a>User-Defined Issue（用户自定义问题）</h5><p>分析：使用<code>#warning</code>之后引发的warning，为User-Defined Issue。这中警告一般是用户自定义或是系统预先定义的，警告级别，可高可低，因此这里不打分。</p>
<h5 id="Format-String-Issue（格式化字符串问题）"><a href="#Format-String-Issue（格式化字符串问题）" class="headerlink" title="Format String Issue（格式化字符串问题）"></a>Format String Issue（格式化字符串问题）</h5><p>分析：该问题通常是基本数据类型转<code>NSString</code>时，出现这样的问题。点击问题后，再次点击问题框上的<code>fix</code>按钮，就可以修复。这里打2分。</p>
<h5 id="Unused-Entity-Issue（未使用的实体）"><a href="#Unused-Entity-Issue（未使用的实体）" class="headerlink" title="Unused Entity Issue（未使用的实体）"></a>Unused Entity Issue（未使用的实体）</h5><p>分析：项目中有声明后未使用的实体（变量，常量）会报这个警告。有用的话可以注释掉，没用删除掉就可以了。这里打1分。</p>
<h5 id="Value-Conversion-Issue（值转换问题）"><a href="#Value-Conversion-Issue（值转换问题）" class="headerlink" title="Value Conversion Issue（值转换问题）"></a>Value Conversion Issue（值转换问题）</h5><p>当函数中传的参数和定义的参数类型不一致时，会报值转换错误，例如：</p>
<p>Implicit conversion loses integer precision</p>
<p>implicit conversion from enumeration type等，解决方法：传入正确的类型</p>
<p>分析：当传入函数的参数为类型不正确的参数时，容易引发未知问题。这里打7分。</p>
<h5 id="ARC-Retain-Cycle（自动内存管理循环引用）"><a href="#ARC-Retain-Cycle（自动内存管理循环引用）" class="headerlink" title="ARC Retain Cycle（自动内存管理循环引用）"></a>ARC Retain Cycle（自动内存管理循环引用）</h5><p>分析：循环引用时OC开发中经常遇到的问题。当Xcode提示循环引用时，一般是比较明显的循环引用。循环引用导致内存泄漏，严重的情况，会导致内存暴增，App Crash。因此，遇到循环引用，应及时解决。这里打10分。</p>
<h5 id="Deprecations（过期不推荐使用）"><a href="#Deprecations（过期不推荐使用）" class="headerlink" title="Deprecations（过期不推荐使用）"></a>Deprecations（过期不推荐使用）</h5><p>分析：使用过期的方法会报<code>Deprecations</code>问题。过期方法都不推荐使用，一本情况，过期的方法又能正常运行。这里打6分，推荐遇到<code>Deprecations</code>问题改为合适的方法。</p>
<h5 id="Asset-Catalog-Compiler-Warning（资源文件编译警告）"><a href="#Asset-Catalog-Compiler-Warning（资源文件编译警告）" class="headerlink" title="Asset Catalog Compiler Warning（资源文件编译警告）"></a>Asset Catalog Compiler Warning（资源文件编译警告）</h5><p>当<code>Assets.xcassets</code>中的文件，编译时出现异常，会报这个警告。例如：</p>
<p>The image set name “xxx” is used by multiple image sets.</p>
<p>app icon is required for iPad/iPhone apps targeting IOS 7.0 and later</p>
<p>解决方法：正确的使用放入图片，包括尺寸，名字不能重复。</p>
<p>分析：当图片使用不当时，会直观的显示在UI上，这对App的美观时致命的。这里打8分。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>经过排序结果如下：</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Score</th>
</tr>
</thead>
<tbody><tr>
<td>ARC Retain Cycle（自动内存管理循环引用）</td>
<td>10</td>
</tr>
<tr>
<td>Asset Catalog Compiler Warning（资源文件编译警告）</td>
<td>8</td>
</tr>
<tr>
<td>Value Conversion Issue（值转换问题）</td>
<td>7</td>
</tr>
<tr>
<td>Dependency Analysis Warning（依赖分析警告）</td>
<td>6</td>
</tr>
<tr>
<td>Deprecations（过期不推荐使用）</td>
<td>6</td>
</tr>
<tr>
<td>Lexical or Preprocessor Issue（词汇或预处理程序问题）</td>
<td>5</td>
</tr>
<tr>
<td>Semantic Issue（语义问题）</td>
<td>4</td>
</tr>
<tr>
<td>Documentation Issue（文档问题）</td>
<td>2</td>
</tr>
<tr>
<td>Format String Issue（格式化字符串问题）</td>
<td>2</td>
</tr>
<tr>
<td>Unused Entity Issue（未使用的实体）</td>
<td>1</td>
</tr>
<tr>
<td>User-Defined Issue（用户自定义问题）</td>
<td>根据情况而定</td>
</tr>
</tbody></table>
<p>建议遇到五分及以上的警告，及时处理，以免造成无法预料的错误。</p>
<p>希望开发者（包括我）在编码时，就顺手解决警告，尽量做到零警告。</p>
<h4 id="Xcode-Analyze警告"><a href="#Xcode-Analyze警告" class="headerlink" title="Xcode Analyze警告"></a>Xcode Analyze警告</h4><p>当使用Xcode <code>Analyze</code>进行分析工程时，也会分析出一些警告。而且分析的警告，大都是必须修复的，这里不在分级，遇到应及时解决。大概有这几中类型：</p>
<ul>
<li><p>API Misuse（API滥用）</p>
</li>
<li><p>Logic error（逻辑错误）</p>
</li>
<li><p>Dead Store（无作用存储体）</p>
</li>
<li><p>Leak（内存泄漏）</p>
</li>
<li><p>Memory error（内存错误）</p>
</li>
</ul>
<p><a href="https://blog.csdn.net/it_liuchengli/article/details/52948031">这里</a>有更详细的解释，有兴趣可以再看看。</p>
<p>谢谢观看！</p>
]]></content>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>“简单图床”发布了</title>
    <url>/2020/07/22/%E2%80%9C%E7%AE%80%E5%8D%95%E5%9B%BE%E5%BA%8A%E2%80%9D%E5%8F%91%E5%B8%83%E4%BA%86/</url>
    <content><![CDATA[<p>&emsp;&emsp;<code>简单图床</code>前两天发布了，<a href="https://apps.apple.com/cn/app/%E7%AE%80%E5%8D%95%E5%9B%BE%E5%BA%8A/id1524122388">点击</a>可转到AppStore。</p>
<a id="more"></a>

<h3 id="名字"><a href="#名字" class="headerlink" title="名字"></a>名字</h3><p>&emsp;&emsp;本来想的App名字叫<code>简图</code>作为简单图床的缩写，没想到AppStore审核通过不了，只能使用<code>简单图床</code>，这样也挺好，四个字意思更明确了，简单明了。<br>&emsp;&emsp;在做App国际化的时候，对于日文App名字的翻译，我找了很久，没找到合适的翻译。最后只能使用<code>簡単な図</code>这样的翻译先用着了。我在AppStore日文介绍里说明了这个情况，请日本的网友给我留言，翻译出一个合适的名字。希望能收到日本网友的回应吧。</p>
<h3 id="收费"><a href="#收费" class="headerlink" title="收费"></a>收费</h3><p>&emsp;&emsp;关于收费这个我也思考了很久，目前是免费。先为爱发电吧。也考虑过一直免费然后接入广告来变相的多点收入，但是想了想，我还是不能接受广告的那种体验。如果以后实在想不到好的办法，就只能接入广告了。<br>&emsp;&emsp;其实这个工具应用免费是最好的，奈何苹果的账号每年都要99刀，一直为爱发电也不是办法。希望以后能找到好的收费模式。</p>
<h3 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h3><p>&emsp;&emsp;应该会写一个关于Github图床的怎么使用的教程。虽然网上也有很多类似的教程，但是我看到前不久Github好像改版UI，我就写个最新的吧。<br>&emsp;&emsp;目前这个软件只接入了Github，未来还想接入更多的图床，但是我现在还没有立即去做的想法。愿景是能够做到和PicGo支持的一样多的平台。</p>
<h3 id="做酷的事情"><a href="#做酷的事情" class="headerlink" title="做酷的事情"></a>做酷的事情</h3><p>&emsp;&emsp;我一直觉得能够把自己的想法变成现实是一件很酷的事。<strong>说到做到</strong>是真的很酷了。<br>&emsp;&emsp;<code>简单图床</code>只是我的一个想法，如今成真，我也收获了一些喜悦。<br>&emsp;&emsp;开发经验其实没什么长进，主要是这个App太简单了。但是我觉得最不简单的是有这个想法并付出行动。<br>&emsp;&emsp;勿以善小而不为。<br>&emsp;&emsp;去做酷的事儿吧！</p>
]]></content>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>一个NSObject对象占用多少内存</title>
    <url>/2023/12/13/%E4%B8%80%E4%B8%AANSObject%E5%AF%B9%E8%B1%A1%E5%8D%A0%E7%94%A8%E5%A4%9A%E5%B0%91%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<p>OC类型的代码，底层实现都是C/C++语言，可以说，OC语言就是对C/C++语言的封装，比如，任何OC对象，添加<code>__bridge const void *</code>修饰，都可以转变为void指针类型。</p>
<a id="more"></a>

<h3 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h3><p>使用<a href="https://zhuanlan.zhihu.com/p/656699711?utm_id=0">Clang</a>可以将OC代码，重写为C++代码。<br>  xcrun 是 Command Line Tools 中的一员。它的作用类似 RubyGem 里的 Bundle ，用于控制执行环境。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc oc文件 -o 输出的cpp文件</span><br></pre></td></tr></table></figure>

<p>新建一个Xcode Project，选择macOS-&gt;Application-&gt;Command Line Tool,打开工程，在main.m文件中改为如下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        &#x2F;&#x2F; insert code here...</span><br><span class="line">        NSObject *obj &#x3D; [[NSObject alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打开终端，cd到main.m目录，根据上面命令，输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main.cpp</span><br></pre></td></tr></table></figure>

<p>如有报错，请去下文<code>错误</code>处查找解决办法。<br>如无报错，可在文件夹中，找到main.cpp文件，打开，将光标移动到最后，可见以下C++代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; An opaque type that represents an Objective-C class.</span><br><span class="line">typedef struct objc_class *Class;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; Represents an instance of a class.</span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class _Nonnull isa;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct objc_object NSObject;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    &#x2F;* @autoreleasepool *&#x2F; &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        NSObject *obj &#x3D; ((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;NSObject&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此可见，一个NSObject对象，它的底层，其实是一个struct, 因此NSObject *其实是一个结构体指针，所以任何OC对象都可以使用<code>(__bridge const void *)</code>将其转化为C语言指针。</p>
<blockquote>
<p>指针类型占据的存储空间取决于编译器和操作系统的实现。在一些32位系统中，一个指针变量通常占据4个字节的空间，而在一些64位系统中，则需要8个字节的空间。这是因为指针是内存地址的数字表示，在32位系统中，一个数字数字占据4个字节的空间，而在64位系统中则需要8个字节。</p>
</blockquote>
<p>而在64位机器中，指针占用8个字节。objc_object中的isa，其实是一个class指针，因此，一个NSObject，只需要8个字节就可以存下。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>objc/runtime.h中，由这样一个方法，返回一个类的实例的大小</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Returns the size of instances of a class.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param cls A class object.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return The size in bytes of instances of the class \e cls, or \c 0 if \e cls is \c Nil.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">OBJC_EXPORT <span class="keyword">size_t</span></span><br><span class="line">class_getInstanceSize(Class _Nullable cls) </span><br><span class="line">    OBJC_AVAILABLE(<span class="number">10.5</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>);</span><br></pre></td></tr></table></figure>

<p>我们知道，在<code>malloc/malloc.h</code>中，有个malloc_size方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extern size_t malloc_size(const void *ptr);</span><br><span class="line">    &#x2F;* Returns size of given ptr, including any padding inserted by the allocator *&#x2F;</span><br></pre></td></tr></table></figure>

<p>返回给定指针的大小，包括分配器插入的填充量。<br>在 main.m中，输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSLog(@&quot;%lu,%zu&quot;, class_getInstanceSize([NSObject class]));</span><br><span class="line">&#x2F;&#x2F;输出:8</span><br><span class="line">NSLog(@&quot;%lu&quot;, malloc_size((__bridge const void *)(obj)));</span><br><span class="line">&#x2F;&#x2F;输出:16</span><br></pre></td></tr></table></figure>

<p>出现两种结果。我们查看<a href="https://github.com/apple-oss-distributions/objc4/tree/objc4-906">Objc4</a>的源码,下载后打开工程，可查到如下源码:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">class_getInstanceSize</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> cls-&gt;alignedInstanceSize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Class&#x27;s ivar size rounded up to a pointer-size boundary.</span></span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">alignedInstanceSize</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> word_align(unalignedInstanceSize());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>发现class_getInstanceSize实际上返回的是类的成员变量的大小，并且按照指针大小（8个字节）取整。<br>因此，我们应当用malloc_size返回的结果。这个结果才是系统为obj分配的大小。<br>经过阅读<a href="https://www.jianshu.com/p/adda1f61a0e8">libmalloc</a>的源码，发现malloc其实是按照16个字节对齐的，因此，一个对象的内存大小一定是16的倍数。</p>
<h3 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">var</span> obj = <span class="type">NSObject</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="type">MemoryLayout</span>.size(ofValue: obj))</span><br><span class="line"><span class="built_in">print</span>(class_getInstanceSize(<span class="type">NSObject</span>.<span class="keyword">self</span>))</span><br><span class="line"><span class="keyword">let</span> objRawPtr = <span class="type">Unmanaged</span>.passUnretained(obj <span class="keyword">as</span> <span class="type">AnyObject</span>).toOpaque()</span><br><span class="line"><span class="built_in">print</span>(malloc_size(objRawPtr))</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//8</span></span><br><span class="line"><span class="comment">//8</span></span><br><span class="line"><span class="comment">//16</span></span><br></pre></td></tr></table></figure>

<p>同样，Swift的底层也是C++代码。将对象转为指针，使用<code>malloc_size</code>也能得到Swift对象的大小。</p>
<h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><p>1.xcrun error</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xcrun: error: SDK &quot;iphoneos&quot; cannot be located</span><br><span class="line">xcrun: error: Failed to open property list &#39;&#x2F;Users&#x2F;tongyulong&#x2F;Documents&#x2F;Test&#x2F;test01&#x2F;test01&#x2F;iphoneos&#x2F;SDKSettings.plist&#39;</span><br><span class="line">main.m:8:9: fatal error: &#39;Foundation&#x2F;Foundation.h&#39; file not found</span><br><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line">        ^~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">main.m:8:9: note: did not find header &#39;Foundation.h&#39; in framework &#39;Foundation&#39; (loaded from &#39;&#x2F;System&#x2F;Library&#x2F;Frameworks&#39;)</span><br><span class="line">1 error generated.</span><br></pre></td></tr></table></figure>

<p>一般情况，出现上诉错误，就是sdk路径错误。<br>在命令行输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xcodebuild -showsdks</span><br></pre></td></tr></table></figure>

<p>如果出现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xcode-select: error: tool &#39;xcodebuild&#39; requires Xcode, but active developer directory &#39;&#x2F;Library&#x2F;Developer&#x2F;CommandLineTools&#39; is a command line tools instance</span><br></pre></td></tr></table></figure>

<p>输入以下命令解决。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo xcode-select --switch &#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;</span><br></pre></td></tr></table></figure>

<p>然后继续执行xrcun</p>
]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>一千种人生</title>
    <url>/2020/05/29/%E4%B8%80%E5%8D%83%E7%A7%8D%E4%BA%BA%E7%94%9F/</url>
    <content><![CDATA[<p>&emsp;&emsp;不知道从哪一刻开始，脑海里会如电影胶片般浮现各种场景，似是平行时空，让我觉得那就是我经历的一样。<br>&emsp;&emsp;等到这种想法蹦出的越来越多，越来越频繁的时候，我决定把这些写出来。<br>&emsp;&emsp;我在标签里面添加了一个新标签，叫做<code>一千种人生</code>。<br>&emsp;&emsp;你是否也有一千种人生？</p>
]]></content>
      <tags>
        <tag>一千种人生</tag>
      </tags>
  </entry>
  <entry>
    <title>一次漫长的AppStore审核经历</title>
    <url>/2020/05/06/%E4%B8%80%E6%AC%A1%E6%BC%AB%E9%95%BF%E7%9A%84AppStore%E5%AE%A1%E6%A0%B8%E7%BB%8F%E5%8E%86/</url>
    <content><![CDATA[<p>最近发布了一款Mac系统环境下的App，名字叫做“<a href="https://apps.apple.com/us/app/%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%89%A9%E5%B1%95/id1491889350?l=zh&ls=1">二维码扩展</a>”，发布过程比正常的发布过程多花了不少时间，历时一个多月。在此记录一下。</p>
<p>第一次提交审核，第二天就出来审核结果了，是由于App的语言适配除了问题，然后我迅速修复了。</p>
<p>再次提交审核，App审核状态变为审核中<code>In Review</code>，然后就开始了漫长的等待。</p>
<a id="more"></a>

<p>等了大概一周多的时间，我收到了苹果一封邮件，如下</p>
<blockquote>
<p>发件人 Apple</p>
<p>Hello,  </p>
<p>We are unable to continue this app’s review because your Apple Developer Program account is currently under investigation for not following the App Store Review Guidelines’ Developer Code of Conduct.  </p>
<p>Common practices that may lead to an investigation include, but are not limited to:  </p>
<ul>
<li>Inaccurately describing an app or service  </li>
<li>Misleading app content  </li>
<li>Engaging in inauthentic ratings and reviews manipulation  </li>
<li>Providing misleading customer support responses  </li>
<li>Providing misleading responses in Resolution Center  </li>
<li>Engaging in misleading purchasing or bait-and-switch schemes  </li>
<li>Engaging in other dishonest or fraudulent activity within or outside of the app  </li>
</ul>
<p>During our investigation, we will not review any apps you submit. Once we have completed our investigation, we will notify you via Resolution Center.  </p>
<p>We do not require any additional information from you at this time, nor do we have any additional details to share. We appreciate your continued patience during our investigation.  </p>
<p>Best regards,  </p>
<p>App Store Review</p>
</blockquote>
<p>简单的来说，就是我的开发者账户<code>Apple Developer Program account</code> 可能违反了苹果的某些规定，被审查了，App审核状态变为已拒绝。虽然事实上并没有违反，为什么这么说，继续看就知道了。</p>
<p>收到这封邮件之后，我又开始了漫长的等待，因为邮件中说，不需要我提供什么额外信息，只需要等就行了。</p>
<p>等了两周没有收到苹果的邮件，我实在焦急，便访问了<a href="https://developer.apple.com/contact/#!/topic/select">苹果技术支持</a>的站点，提交了一个issue。具体选择的是会员资格与问题，然后又选择了其他会员资格与账户问题。</p>
<p><img src="https://raw.githubusercontent.com/lengain/LengainGraphBed/master/picture/%E6%88%AA%E5%B1%8F2020-05-06%20%E4%B8%8B%E5%8D%8812.43.30.png" alt></p>
<p>我详细的描述了我审核的过程，并解释说我这只是个工具类App，并未违反之前苹果邮件中提到的规定，请他们协助调查，帮忙查一下审查两周还没有通过原因。</p>
<p>第二天，我收到了苹果技术支持中心的邮件，邮件中说我的账户是正常的审查状态，要我耐心等待。</p>
<p>不知道是不是联系苹果技术支持起了作用，之后没两天我便收到苹果的调查结果，如下：</p>
<blockquote>
<p>发件人 Apple</p>
<p>Hello,  </p>
<p>We are writing to let you know that we have completed our investigation of your Apple Developer Program account. You may now submit apps for review, and we will continue with the review of this app. If we find any issues during our review, we will communicate them via Resolution Center. Otherwise, your app will be approved.  </p>
<p>Please note that all apps submitted to the App Store are reviewed against the  <a href="https://developer.apple.com/app-store/review/guidelines/">App Store Review Guidelines</a>, including the  <a href="https://developer.apple.com/app-store/review/guidelines/#code-of-conduct">Developer Code of Conduct</a>.  </p>
<p>You can avoid future investigations by ensuring your apps don’t attempt to mislead or harm customers or undermine the review process. Be sure to review the  <a href="https://developer.apple.com/app-store/review/guidelines/">App Store Review Guidelines</a>  and read the  <a href="https://developer.apple.com/app-store/review/guidelines/#code-of-conduct">Developer Code of Conduct</a>  so you understand our requirements prior to submitting any apps for review.  </p>
<p>Best regards,  </p>
<p>App Store Review</p>
</blockquote>
<p>说了半天，其实我也没有违反规定，就被审查了二十天。然后状态变为正在审核，又等了一个星期，审核通过。<br>审核通过后，App并没有直接发布到AppStore，当时是搜索不到的，苹果会在24小时之内传到各个国家地区的AppStore。<br>完结，手动撒花~</p>
]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>两天</title>
    <url>/2020/06/10/%E4%B8%A4%E5%A4%A9/</url>
    <content><![CDATA[<center>
今年只有两天

<p>一天开心<br>一天悲伤</p>
<p>一天清爽<br>一天油腻</p>
</center>
]]></content>
      <tags>
        <tag>有件小事</tag>
      </tags>
  </entry>
  <entry>
    <title>二维码扩展app隐私政策</title>
    <url>/2020/04/04/%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%89%A9%E5%B1%95app%E9%9A%90%E7%A7%81%E6%94%BF%E7%AD%96/</url>
    <content><![CDATA[<h4 id="二维码扩展服务协议及隐私政策"><a href="#二维码扩展服务协议及隐私政策" class="headerlink" title="二维码扩展服务协议及隐私政策"></a>二维码扩展服务协议及隐私政策</h4><p>欢迎您使用二维码扩展！<br>为使用二维码扩展，您应当阅读并遵守《二维码扩展服务协议》（以下简称“本协议”）。请您务必审慎阅读、充分理解各条款内容，特别是免除或限制责任的相应条款，以及开通或使用某项服务的单独协议，您使用此服务即表示您接受本协议。限制或免除责任条款可能以加粗形式提示您注意。 除非您已阅读并接受本协议所有条款，否则您无权使用二维码扩展服务（以下简称“本服务”）。您对本服务的任何查看使用行为即视为您已阅读并同意本协议的约束。</p>
<a id="more"></a>

<h2 id="一、协议的范围"><a href="#一、协议的范围" class="headerlink" title="一、协议的范围"></a>一、协议的范围</h2><h3 id="1-1【协议适用主体范围】"><a href="#1-1【协议适用主体范围】" class="headerlink" title="1.1【协议适用主体范围】"></a>1.1【协议适用主体范围】</h3><p>本协议是您与二维码扩展之间关于您使用本服务所订立的协议。</p>
<h3 id="1-2【本服务内容】"><a href="#1-2【本服务内容】" class="headerlink" title="1.2【本服务内容】"></a>1.2【本服务内容】</h3><p>本协议项下的服务是指二维码扩展向用户提供的服务（以下简称“本服务”）。本协议内容同时包括二维码扩展可能不断发布的关于本服务的相关协议、业务规则等内容。上述内容一经正式发布，即为本协议不可分割的组成部分，您同样应当遵守。</p>
<h2 id="二、隐私政策"><a href="#二、隐私政策" class="headerlink" title="二、隐私政策"></a>二、隐私政策</h2><p>a）本产品不会采集您的个人信息。</p>
<p>b）本产品亦不允许任何第三方以任何手段收集、编辑、出售或者无偿传播</p>
<p>您的个人信息。任何本产品平台用户如从事上述活动，一经发现，本产品</p>
<p>有权立即终止与该用户的服务协议。</p>
<h2 id="三、权利义务"><a href="#三、权利义务" class="headerlink" title="三、权利义务"></a>三、权利义务</h2><h3 id="3-1-【关于收费】"><a href="#3-1-【关于收费】" class="headerlink" title="3.1 【关于收费】"></a>3.1 【关于收费】</h3><p>本服务是二维码扩展向您提供的免费服务，您可免费试用本服务任何内容，方可使用本服务。否则，您无权使用本服务。二维码扩展可能会根据本服务的整体规划，对本服务的收费标准、方式等进行修改和变更，前述修改、变更，二维码扩展将在相应服务页面进行通知或公告。如果您不同意上述修改、变更，则应停止使用本服务。否则，您的任何购买、登录、查看等使用行为，即视为您同意上述修改、变更。</p>
<h3 id="3-2【服务开通】"><a href="#3-2【服务开通】" class="headerlink" title="3.2【服务开通】"></a>3.2【服务开通】</h3><p>您应该通过二维码扩展开通本服务。您承诺不得通过非二维码扩展指定途径或任何违反相关法规、违反本协议、不正当手段等开通、获取本服务。</p>
<h3 id="3-3-【服务期限】"><a href="#3-3-【服务期限】" class="headerlink" title="3.3 【服务期限】"></a>3.3 【服务期限】</h3><p>本服务自您依约完成有效之日起生效。</p>
<h3 id="3-4-【行为规范】"><a href="#3-4-【行为规范】" class="headerlink" title="3.4 【行为规范】"></a>3.4 【行为规范】</h3><h4 id="3-4-1【五不准】"><a href="#3-4-1【五不准】" class="headerlink" title="3.4.1【五不准】"></a>3.4.1【五不准】</h4><p>您在使用本服务时不得利用本服务从事以下行为，包括但不限于：</p>
<p>（1）发布、传送、传播、储存违反国家法律、危害国家安全统一、社会稳定、公序良俗、社会公德以及侮辱、诽谤、淫秽、暴力的内容；</p>
<p>（2）发布、传送、传播、储存侵害他人名誉权、肖像权、知识产权、商业秘密等合法权利的内容；</p>
<p>（3）虚构事实、隐瞒真相以误导、欺骗他人；</p>
<p>（4）发表、传送、传播广告信息及垃圾信息；</p>
<p>（5）从事其他违反法律法规、政策及公序良俗、社会公德等的行为。</p>
<h4 id="3-4-2【用户禁止行为】"><a href="#3-4-2【用户禁止行为】" class="headerlink" title="3.4.2【用户禁止行为】"></a>3.4.2【用户禁止行为】</h4><p>本服务仅供您个人使用，除非经二维码扩展书面许可，您不得进行以下行为：</p>
<p>（1）通过任何方式搜集本服务中其他用户的用户名、电子邮件等相关信息，并以发送垃圾邮件、连锁邮件、垃圾短信、即时消息等方式干扰、骚扰其他用户；</p>
<p>（2）通过本服务发布包含广告、宣传、促销等内容的信息；</p>
<p>（3）将本服务转让许可他人使用；</p>
<p>（4）其他未经二维码扩展书面许可的行为。</p>
<h4 id="3-4-3【行为责任】"><a href="#3-4-3【行为责任】" class="headerlink" title="3.4.3【行为责任】"></a>3.4.3【行为责任】</h4><p>您充分了解并同意，您必须为自己使用二维码扩展下的一切行为负责，包括您所发表的任何内容以及由此产生的任何后果。您应对本服务中的内容自行加以判断，并承担因使用内容而引起的所有风险，包括因对内容的正确性、完整性或实用性的依赖而产生的风险。二维码扩展无法且不会对因前述风险而导致的任何损失或损害承担任何责任。</p>
<h3 id="3-5【服务的变更、中止或终止】"><a href="#3-5【服务的变更、中止或终止】" class="headerlink" title="3.5【服务的变更、中止或终止】"></a>3.5【服务的变更、中止或终止】</h3><p>您充分了解并同意，由于互联网服务的特殊性，二维码扩展可以在不提前通知您的情况之下，根据本服务的整体规划，对本服务内容进行变更、中止或终止。</p>
<h2 id="四、违约责任"><a href="#四、违约责任" class="headerlink" title="四、违约责任"></a>四、违约责任</h2><p>4.1 如果二维码扩展发现或收到他人举报您有违反本协议任何行为的，二维码扩展有权进行独立判断并采取技术手段予以删除、屏蔽或断开相关的信息。同时，二维码扩展有权视您的行为性质，对您采取包括但不限于暂停或终止部分或全部本服务、中止或终止您对账号的使用、追究法律责任等措施，而由此给您带来的损失（包括但不限于通信中断、相关数据清空、服务费用作为违约金而归二维码扩展所有等），由您自行承担，造成二维码扩展损失的，您也应予以赔偿。若二维码扩展依前述约定对您采取暂停或终止部分或全部本服务的，二维码扩展无需向您退还任何费用，剩余的服务费用，作为违约金而归二维码扩展所有。</p>
<h3 id="4-2-【对第三方损害的处理】"><a href="#4-2-【对第三方损害的处理】" class="headerlink" title="4.2 【对第三方损害的处理】"></a>4.2 【对第三方损害的处理】</h3><p>您有违反本协议任何行为，导致任何第三方损害的，您应当独立承担责任；二维码扩展因此遭受损失的，您也应当一并赔偿。</p>
<h3 id="4-3-【单方提前终止服务】"><a href="#4-3-【单方提前终止服务】" class="headerlink" title="4.3 【单方提前终止服务】"></a>4.3 【单方提前终止服务】</h3><p>您充分了解并同意，您在选择使用本服务后，若您在无任何法定或约定理由的情况之下，单方要求提前终止本服务的，二维码扩展无需向您退还任何费用，剩余的服务费用，作为违约金而归二维码扩展所有。</p>
<h2 id="五、其他"><a href="#五、其他" class="headerlink" title="五、其他"></a>五、其他</h2><h3 id="5-1-【协议的生效与变更】"><a href="#5-1-【协议的生效与变更】" class="headerlink" title="5.1 【协议的生效与变更】"></a>5.1 【协议的生效与变更】</h3><p>您使用本服务即视为您已阅读并同意受本协议的约束。二维码扩展有权在必要时修改本协议条款。您可以在相关页面中查阅最新的协议条款。本协议条款变更后，如果您继续使用本服务，即视为您已接受修改后的协议。如果您不接受修改后的协议，应当停止使用本服务。</p>
<h3 id="5-2-【协议签订地】"><a href="#5-2-【协议签订地】" class="headerlink" title="5.2 【协议签订地】"></a>5.2 【协议签订地】</h3><p>本协议签订地为中华人民共和国。</p>
<h3 id="5-3-【适用法律】"><a href="#5-3-【适用法律】" class="headerlink" title="5.3 【适用法律】"></a>5.3 【适用法律】</h3><p>本协议的成立、生效、履行、解释及纠纷解决，适用中华人民共和国大陆地区法律（不包括冲突法）。</p>
<h3 id="5-4-【争议解决】"><a href="#5-4-【争议解决】" class="headerlink" title="5.4 【争议解决】"></a>5.4 【争议解决】</h3><p>若您和二维码扩展之间发生任何纠纷或争议，首先应友好协商解决；协商不成的，您同意将纠纷或争议提交本协议签订地有管辖权的人民法院管辖。</p>
<h3 id="5-5-【条款标题】"><a href="#5-5-【条款标题】" class="headerlink" title="5.5 【条款标题】"></a>5.5 【条款标题】</h3><p>本协议所有条款的标题仅为阅读方便，本身并无实际涵义，不能作为本协议涵义解释的依据。</p>
<h3 id="5-6-【条款效力】"><a href="#5-6-【条款效力】" class="headerlink" title="5.6 【条款效力】"></a>5.6 【条款效力】</h3><p>本协议条款无论因何种原因部分无效或不可执行，其余条款仍有效，对双方仍具有约束力。</p>
]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>云南省7天旅游攻略</title>
    <url>/2019/01/07/%E4%BA%91%E5%8D%97%E7%9C%817%E5%A4%A9%E6%97%85%E6%B8%B8%E6%94%BB%E7%95%A5/</url>
    <content><![CDATA[<p><img src="/2019/01/07/%E4%BA%91%E5%8D%97%E7%9C%817%E5%A4%A9%E6%97%85%E6%B8%B8%E6%94%BB%E7%95%A5/%E4%BA%91%E5%8D%97%E6%97%85%E6%B8%B8%E5%9C%B0%E5%9B%BE.jpg" alt="云南旅游地图"></p>
<p>2019新年，放假十天。和几个朋友一商量，决定过年不回家了，去云南旅游。</p>
<p>前几天买了高铁票，今天规划一下旅游路线，以便买返程高铁。</p>
<p>计划出游七天：</p>
<a id="more"></a>

<h4 id="第一天-2月1号-（腊月二十七）"><a href="#第一天-2月1号-（腊月二十七）" class="headerlink" title="第一天 2月1号 （腊月二十七）"></a>第一天 2月1号 （腊月二十七）</h4><p>杭州出发，到昆明。G1379 杭州东(9:28)-昆明南(20:19) </p>
<p>晚上：高铁去大理 150元 两个小时 晚上住大理</p>
<p>消费:900 + 150（交通）+ 200（住宿） = 1250</p>
<h4 id="第二天-2月2号-（腊月二十八）大理"><a href="#第二天-2月2号-（腊月二十八）大理" class="headerlink" title="第二天 2月2号 （腊月二十八）大理"></a>第二天 2月2号 （腊月二十八）大理</h4><p><img src="/2019/01/07/%E4%BA%91%E5%8D%97%E7%9C%817%E5%A4%A9%E6%97%85%E6%B8%B8%E6%94%BB%E7%95%A5/%E5%A4%A7%E7%90%86%E6%97%85%E6%B8%B8%E5%9C%B0%E5%9B%BE.jpeg" alt="大理旅游地图"></p>
<p>洱海（洱海游船 南诏风情岛4A<code>洱海东岸 40元</code>）上午</p>
<p>大理古城 (洋人街) 下午</p>
<p>待议：苍山 蝴蝶泉4A，崇圣寺三塔文化旅游区</p>
<p>晚上：大理 (8:31)到丽江(9:52) 52元 D8791 住宿 丽江 睡眠浅的话建议住在束河古镇，束河古镇整体相对于古城来说就清静许多了</p>
<blockquote>
<p>大理到丽江2个小时左右车程，到丽江两种方式：1是火车（34 硬座 2小时），2是客车（2.5小时 75元），</p>
</blockquote>
<p>消费：500左右（吃喝逛住）</p>
<h4 id="第三天-2月3号-（腊月二十九）丽江"><a href="#第三天-2月3号-（腊月二十九）丽江" class="headerlink" title="第三天 2月3号 （腊月二十九）丽江"></a>第三天 2月3号 （腊月二十九）丽江</h4><p><img src="/2019/01/07/%E4%BA%91%E5%8D%97%E7%9C%817%E5%A4%A9%E6%97%85%E6%B8%B8%E6%94%BB%E7%95%A5/%E4%B8%BD%E6%B1%9F%E6%99%AF%E7%82%B9%E5%9C%B0%E5%9B%BE.jpg" alt="丽江景点地图"></p>
<p>先去泸沽湖。</p>
<p>泸沽湖的<a href="http://you.ctrip.com/sight/luguhu105/4200.html">携程介绍</a>还是挺详细的。</p>
<blockquote>
<ol>
<li>泸沽湖畔海拔较高，一旦遇到阴雨天则温度骤降，所以无论何时来泸沽湖，都要记得带一两件保暖衣物。 </li>
<li>摩梭人因为实行走婚制，所以没有严格意义上的父亲，一家人以祖母为长，孩子以舅舅为大。在泸沽湖畔摩梭人聚居区，不能问孩子的父亲是谁。 </li>
<li>泸沽湖是当地人赖以为生的水面，所以，不能在湖中洗澡游泳。 </li>
<li>摩梭人的咣当酒又称走婚酒，喝起来口感不错，但是后劲颇足，需要注意。另外，当地的烤乳猪可以一试，皮脆肉酥，可以7-8人同吃。</li>
</ol>
</blockquote>
<h4 id="第四天-2月4号-（腊月二十三十-除夕）丽江"><a href="#第四天-2月4号-（腊月二十三十-除夕）丽江" class="headerlink" title="第四天 2月4号 （腊月二十三十 除夕）丽江"></a>第四天 2月4号 （腊月二十三十 除夕）丽江</h4><p>四号和五号两天的行程可能互换。</p>
<p>拉市海因为离丽江比较紧，加上游览了泸沽湖之后，看拉市海应该玩不太久。下午与实践就逛逛古城。</p>
<p>上午：拉市海（丽江城西10公里）</p>
<blockquote>
<p>客栈会有跟拉市海的团合作，200来块钱。</p>
<p>要找拉市海一天游，划船骑马吃饭，野团是坑，骑马谈好100多就能搞定，还包一顿饭。 骑着马走茶马古道。</p>
<p>1.拉市海周边有很多马场，不过服务和态度良莠不齐，注意提前谈好价格和服务细节，以免被坑。</p>
<p>2.骑马游玩时，记得钱包、手机等物品不要放在衣服外兜，不然很容易在马奔跑的过程中消失，马场的马夫每年都能捡到很多此类物品。</p>
<p>3.骑马时马全程基本都是在走，别期望能像赛马一样跑起来，当然，好处是也基本不用担心安全问题。</p>
</blockquote>
<p>下午：丽江古城（大研镇）木府 古城大水车</p>
<p>束河古镇（30元）</p>
<p>虎跳峡待议 3号4号 有时间去一趟虎跳峡</p>
<h4 id="第五天-2月5号（正月初一-春节）丽江"><a href="#第五天-2月5号（正月初一-春节）丽江" class="headerlink" title="第五天 2月5号（正月初一 春节）丽江"></a>第五天 2月5号（正月初一 春节）丽江</h4><p>玉龙雪山 （丽江古城以北15公里处）</p>
<p>景区停车场氧气100一瓶，提前在古城买好了25一瓶。</p>
<p>进山费120元，环保车20元，大索道180元（还有中索道和小索道，但是我觉得玉龙雪山还是一定要走大索道才值得）防寒服60元，氧气60到120元。 我们选择的是玉龙雪山商务车纯玩一日游的团，价格是480元全含（可以微信搜索“云南旅游商城”预订），包含了： 丽江到玉龙雪山来回商务车接送，进山费，司机兼向导服务，环保车，大索道，冰川公园，蓝月谷，氧气，防寒服，中餐吃火锅。</p>
<blockquote>
<ol>
<li><p>一般阴雨天气除景色会打折外，不会影响景区开放。暴雨、极端恶劣天气时，索道可能停开，这种情况平时较少，如果遇到恶劣天气，前往游玩前建议电话咨询是否开放。</p>
</li>
<li><p>乘坐大索道海拔提升较快，很多人一下子不适应，建议缓慢行动，防止高原反应。若有不良反应也无须惊慌，可到景区医务室咨询、治疗。景区并不禁止老人、小孩前往，不过因海拔较高提升较快，体质弱的游客建议谨慎考虑。</p>
</li>
<li><p>乘坐大索道上山后，温度会比较低，建议携带适度保暖衣物。一般情况下，在山下的着装基础上，加一两件较厚的外套即可。如果是冬季或者雨雪天气则需带羽绒服（景区内服务点也可以租借）。</p>
</li>
<li><p>玉龙雪山景区空气稀薄，紫外线强烈，在景区游玩需注意防晒，建议提前准备好帽子、墨镜和防晒霜等。</p>
</li>
<li><p>不管是丽江古城周围还是玉龙雪山脚下，都有当地人拉客，建议游人“骑马上山、可看全景”等。不建议采信，这类服务无安全保障，而且骑马是绝对不会上到山顶的。</p>
</li>
<li><p>乘坐大索道上山是最大众的方式，所以每天排队的人都超级多，夸张的时候单是排队可能就要3-4小时。如果不想排队，建议尽早赶到景区。大索道上下加游玩，一般在4-5小时，下山后，吃点东西，顺路玩下周围的小景点后，就可以回古城了。</p>
</li>
</ol>
</blockquote>
<h4 id="第六天-2月6号-（正月初二）香格里拉"><a href="#第六天-2月6号-（正月初二）香格里拉" class="headerlink" title="第六天 2月6号 （正月初二）香格里拉"></a>第六天 2月6号 （正月初二）香格里拉</h4><p><img src="/2019/01/07/%E4%BA%91%E5%8D%97%E7%9C%817%E5%A4%A9%E6%97%85%E6%B8%B8%E6%94%BB%E7%95%A5/%E9%A6%99%E6%A0%BC%E9%87%8C%E6%8B%89%E6%97%85%E6%B8%B8%E5%9C%B0%E5%9B%BE.png" alt="香格里拉旅游地图"></p>
<p>上午：7：30 坐车 到香格里拉</p>
<blockquote>
<p>丽江到香格里拉170km，不通火车，汽车3个多小时，丽江的高快客运站和新客运站坐班车去香格里拉，半个小时左右一趟，运行时间7:30到17:00。</p>
</blockquote>
<p>中午出发去：</p>
<p>普达措国家公园，门票138+园区大巴120元</p>
<blockquote>
<p>“普达措国家公园位于大香格里拉风景区的中心区域，是世界自然遗产“三江并流”风景区的重要组成部分，主要由<a href="http://you.ctrip.com/sight/xianggelila106/56571.html">碧塔海</a>、<a href="http://you.ctrip.com/sight/xianggelila106/56571.html">属都湖</a>和霞给民俗生态文化村三部分组成</p>
<p>公园内主要的两个湖泊：属都湖、碧塔海，分别位于公园的南北两侧，相距10余公里。两湖之间有洛茸村、弥里塘草原等景点。因距离较远，游人一般都乘坐环保观光车，根据车行路线游玩。</p>
<p>入口处乘坐景区环保观光车，约20分钟可抵达属都湖景区。属都湖湖水清澈碧蓝，湖畔是一片绵延的高原牧场。冬季的清晨，湖面上水汽凝结，像一层白雾弥漫在水面上，只有搭乘清早的第一班车到此，方可观赏到这一奇景。草场沿湖搭建有步行栈道，走完一圈大约需要一个小时。栈道尽头就是环保车站，游玩结束上车抵达下一个目的地。</p>
<p>环保车的下一站是弥里塘草原。环保车继续前行，会经过公园游客服务站，这里有桑错卡餐厅，条件一般，价格不便宜。但如果真的累了饿了又没有自带干粮的话，也只能在此吃午餐，顺便休息一下。</p>
<p>碧塔海是环保车路线的末站，也是此行的重头。碧塔海在藏语里是意思是“栎树成毡的海子”，顾名思义，湖畔栎树茂密如绿色的毡子。</p>
<p>公园出来后的路边是霞给民俗生态文化村，村里主要以推介藏民族民俗文化为主，有土陶坊、唐卡坊、木器坊、牛角雕刻坊、藏香坊、民居博物馆、藏银坊等各式各样的民间作坊，摆满了制作精美的民族手工艺品，欣赏之余，也可以适当购买中意的小物件</p>
<ol>
<li><p>普达措国家公园整体海拔3500米-4150米之间，为预防高原反应的发生，建议不要剧烈运动，并适当携带相关药物等预防措施。</p>
</li>
<li><p>普达措公园海拔较高，加之高原气候变化莫测，所以无论何时入园游览，都要记得携带保暖衣物和雨具。如有需要，公园门口有租借羽绒服的服务点。</p>
</li>
<li><p>游玩普达措公园至少需要3-5小时，建议自带饮食。否则只能在园内餐厅享用略贵的食物。</p>
</li>
</ol>
</blockquote>
<h4 id="第七天-2月7号-（正月初三）香格里拉"><a href="#第七天-2月7号-（正月初三）香格里拉" class="headerlink" title="第七天 2月7号 （正月初三）香格里拉"></a>第七天 2月7号 （正月初三）香格里拉</h4><p>上午：</p>
<p>香格里拉大峡谷 巴拉格宗风景名胜区，位于香格里拉市区的东北侧，拥有非常壮阔的自然风光</p>
<p>交通：（如果碰到合适的可包车前往）</p>
<p>香格里拉古城月光停车场–香格里拉大峡谷(巴拉格宗)旅游专线　约50公里　9：00发车 票价50元/人</p>
<blockquote>
<p>景区主要分为峡谷区和巴拉古村两部分，都有观光车相通（车费包含在门票内）。一般游客到达景区会先乘观光车（约40分钟）到巴拉村，游玩1小时左右。然后乘车前往峡谷区域的入口—崖咱（车程约20分钟），游玩峡谷大约2-3小时左右返回大门，全程约需4-6小时。若时间紧张也可以选择仅玩峡谷一项，另外景区深处还有几条徒步路线，大约需要3-5天，专业的户外爱好者也可以前去探寻。巴拉村位于景区的西侧，是一座古老的藏族村寨，这里有上百年前的藏式民居。村子周边，有茂密的植被、陡峭的岩壁，远处就是巍巍雪山.</p>
<p>峡谷区是景区的精华所在，这里沿着香格里拉大峡谷共有多条支峡，目前游客可以游玩的有通天峡和香格里拉大峡谷两处。香格里拉大峡谷非常幽深，其中河流青绿湍急、周围树木茂密，景色壮丽，谷内有5公里栈道，游客沿着栈道步行参观即可（大约1小时）。到达栈道终点后可以乘车出谷前往通天峡，也可以选择在幽深美丽的峡谷里一路漂流而下，到达二号码头后乘车前往通天峡。通天峡谷内最有趣的是700米的悬空栈道，走在上面即能欣赏到优美的景观，又可以体验到刺激的感觉。</p>
<p>除了峡谷和古村外，景区内还有另外“两绝”不能错过，一处是门口附近的千年菩提树，树干长出了人手掌的形状，非常形象，使很多游客为之惊叹。另一绝位于加拉村深处的牧场里，有一座曲登神山，这座山顶部圆形的尖顶被白雪覆盖，下面是黑色的圆形岩壁，很像藏区随处可见的佛塔形状，被称为天然佛塔，参观天然佛塔需要从加拉村里面的公路尽头徒步约一小时到达，感兴趣的游客可以前往。</p>
</blockquote>
<p>下午或晚上：</p>
<p>独克宗月光古城 ，即香格里拉古城 ，没有门票。</p>
<p>预算：300左右</p>
<h4 id="第八天-2月8号-（正月初四）-香格里到-昆明"><a href="#第八天-2月8号-（正月初四）-香格里到-昆明" class="headerlink" title="第八天 2月8号 （正月初四） 香格里到-昆明"></a>第八天 2月8号 （正月初四） 香格里到-昆明</h4><p>上午：独克宗月光古城</p>
<p>中午：十二点多（12：10一班，13：00一班） 香格里拉汽车客运站到丽江  三小时左右</p>
<p>晚上：D8792 丽江到昆明 （208元） 住昆明</p>
<p>预算：400左右</p>
<h4 id="第九天-2月9号-（正月初五）回程"><a href="#第九天-2月9号-（正月初五）回程" class="headerlink" title="第九天 2月9号 （正月初五）回程"></a>第九天 2月9号 （正月初五）回程</h4><p>上午十点半昆明到杭州 火车</p>
<p>预算：950元</p>
<h4 id="旅游注意事项"><a href="#旅游注意事项" class="headerlink" title="旅游注意事项"></a>旅游注意事项</h4><p>1、高原反应，这边的海拔比较高，必须要预防高原反应，提前做一些准备买上抗高原反应的产品，建议你准备氧健能，这是我多次进藏对比下来用得最好的产品。</p>
<p>2、衣服，那边的早晚温差比较大，任何季节去都要带上厚衣服，去之前查查当时的温度在哪个区间，根据自己的体质做准备。  </p>
<p>3、在高原晚上睡觉，尽量开窗透气，要不然容易缺氧。</p>
<p>4、在高海拔地方，最好带上保温杯，尽量喝热水。</p>
<p>5、准备好一些常用的药品，比如感冒药，肠胃药等。在高原千万不要冷感冒了</p>
<blockquote>
<p>1.不要跟机场、车站出口处的拉客仔或拉客大妈去她们推荐的酒店，那可是一条被宰的不归路啊~</p>
<p>2.云南酒店淡旺季差别很大，不要因为淡季来过很便宜就以为全年都是这样的价格哦</p>
<p>3.酒店都需要预定，否则有可能因为后面的客人的预定而不能让你续住，所以旅游之前最好预定好房间.特别是晚上临时找住处会很被动，之前有朋友飞机落地没酒店就很惨，不过我上次全程住宿交通都是天纯安排的</p>
</blockquote>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>从知识屏蔽想到的</title>
    <url>/2020/08/01/%E4%BB%8E%E7%9F%A5%E8%AF%86%E5%B1%8F%E8%94%BD%E6%83%B3%E5%88%B0%E7%9A%84/</url>
    <content><![CDATA[<p>前几天刚阅读完王爽老师的《汇编语言》，在书的末尾看到<code>知识屏蔽</code>这个词，回想良多，让我觉得很有趣。知识屏蔽是一个教学相关的概念，指的是在教学过程中，对知识的传授，循序渐进，有的放矢，对教学无关的内容进行屏蔽，，等到受教育者有一定的知识储备后，再放出之前屏蔽的内容，使受教育者能够更好地学习。</p>
<p><code>知识屏蔽</code>对教育者在学生接受程度的了解上有更高的要求。大部分学习课程都是做到了知识屏蔽，但是能把知识屏蔽做到恰到好处是非常难的。教育者可以在这方面多做努力。教育者要站在学生的角度，从学生的知识储备的基础上，进行设计教学进度和教学内容，一点点的抽丝剥茧，循序渐进的把要讲的知识重现出来。</p>
<p><code>知识屏蔽</code>对教育者的研究能力有更高的要求。这里的教育者指的一个是书的作者，一个是教师。书的作者应该做到自己编写的书，在没有老师的情况下，受教育者能够通过自学，完全学会要传授的知识；而教师要根据教材，做合适的解读和扩展，这里的扩展是对已有知识的扩展，而不是应该屏蔽的超纲知识。</p>
<p>回想起来大学时候，有的计算机课程的教科书，对知识屏蔽做的不好的，学起来晦涩难懂，费时费力。学生学起来困难，老师教起来费劲。还有各种翻译来的专业名词，也应该更贴合国内的语言环境。</p>
<p>切勿故作高深！</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>关于应用“简图”的UI和交互设计</title>
    <url>/2020/06/26/%E5%85%B3%E4%BA%8E%E5%BA%94%E7%94%A8%E2%80%9C%E7%AE%80%E5%9B%BE%E2%80%9D%E7%9A%84UI%E5%92%8C%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h3 id="2020年6月19日"><a href="#2020年6月19日" class="headerlink" title="2020年6月19日"></a>2020年6月19日</h3><p>上段时间在考虑应用的名字，确定好叫<code>简图</code>之后我就开始了开发的工作。</p>
<p>现在卡在第三方账号设置页面的UI设计和交互设计了。我想了很久，但是还没想到好的方案。</p>
<p>先说说主页的设计吧。</p>
<a id="more"></a>

<h4 id="主页"><a href="#主页" class="headerlink" title="主页"></a>主页</h4><p>主页是仿的苹果相册的设计，长按弹出预览和功能菜单。下面是预览图：</p>
<p><img src="https://raw.githubusercontent.com/lengain/LengainGraphBed/master/picture/se2longpress.gif" alt="图1"></p>
<p>夸一下苹果的这个交互设计，这个设计其实是两个之前已有设计的合体，长按弹出功能菜单和3DTouch弹出预览图，或者说是对3D Touch的优化。</p>
<p>在iOS 13之前的相册中，带有3D Touch功能的手机的交互是3DTouch轻按弹出预览图，松手消失;只有轻按后上滑预览图才能弹出功能菜单(UIActionSheet)。如下图：</p>
<p><img src="https://raw.githubusercontent.com/lengain/LengainGraphBed/master/picture/2020-06-19%2023.26.48.gif" alt="图2"></p>
<p>而不带3D Touch的手机则没有任何操作，如果要操作相片，要单击进入详情页操作。如下图：</p>
<p><img src="https://raw.githubusercontent.com/lengain/LengainGraphBed/master/picture/seno3dtouch.gif" alt="图3"></p>
<p>相比较而言iOS 13的处理比3D Touch更为直观，简便，一次长按即可预览，又可操作。</p>
<p>技术角度来讲iOS13为长按预览提供了全新的API，适配时更加方便。我决定为简图主页适配长按预览功能，低于iOS13的系统版本，则适配为长按弹出UIActionSheet，不再提供预览功能。</p>
<h4 id="账号设置页面"><a href="#账号设置页面" class="headerlink" title="账号设置页面"></a>账号设置页面</h4><p>这个页面我迟迟没有想好合适的交互，为了理清思路，首先列出我想要的功能。</p>
<ul>
<li><p>账号显示页面有添加账号按钮</p>
</li>
<li><p>点击按钮后弹出选择账号平台的页面（目前只有一个Github，暂时不做）</p>
</li>
<li><p>编辑添加账号</p>
</li>
<li><p>添加后的账号显示页面可直观的显示当前账号，并且易于切换账号。</p>
</li>
</ul>
<p>有些事情想不好怎么做，就放一放，可能会在哪个阳光温暖的午后，就突然想起来了。</p>
<h3 id="2020年6月26日"><a href="#2020年6月26日" class="headerlink" title="2020年6月26日"></a>2020年6月26日</h3><p>终于想好了账号设置页面的交互，该交互使用传统的iOS风格的切换方式。</p>
<p>首先设置页面只显示当前账号，点击当前账号进入账号设置页面。</p>
<p>账号设置页面的功能：</p>
<ul>
<li><p>添加，删除账号</p>
</li>
<li><p>切换账号，选中新账号后返回设置页面</p>
</li>
</ul>
<p>既简单，又方便。</p>
<p>设置页面的功能：</p>
<ul>
<li><p>显示当前账号</p>
</li>
<li><p>切换上传图片的清晰度</p>
</li>
<li><p>去评分，关于等等</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>关于网上教育的一点思考</title>
    <url>/2020/08/19/%E5%85%B3%E4%BA%8E%E7%BD%91%E4%B8%8A%E6%95%99%E8%82%B2%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<p>最近学了一个网上录播的课程，又想到了大学时代上课的日子，有了一些新的想法。</p>
<p>教育公平的理念强调起点公平、过程公平和结果公平，我们国家一直倡导教育公平，想要尽量均衡的分配教育资源，但是教育公平提出了这么多年，教育公平在社会上的实现依旧不尽人意。就连高考也只是相对的省内公平，各个省市的录取情况一对比，不公平现象立现。高考人数多的省份和高校数量少的省份产生内卷，极度的消耗人才。</p>
<p>就算你走过了高考，上了大学，连大学也分三六九等，985，211，一本二本三本，各个大学之间，教育不公平更是触目惊心。包括教师质量，教学水平，教学设施水平，科研经费划比等等，各个学校千差万别。因此教育公平在大学之间更是无从谈起。</p>
<p>类似教育公平这种社会现象，就是这么奇怪，明明每个人都知道这个事不好，但是因为能凑合，所以大都睁一只眼闭一只眼，然后说一句随大流的话，习惯了就好。我最近思考了这个问题，有一个新想法，希望能为教育公平的实现添一点愚见。</p>
<p><strong>希望国家可以建立统一的课程录播制度</strong>。教师可以利用录播的课程，查找自己不足，提升教学水平；学生可以利用录播的课程进行复习；经教育部门或者学校的整理，将优秀的录播课程上传至教育网，可供全国在校的学生观看，学习；教育部门或学校再经过筛选，可以将录播课程放到公网上，供全国的人民观看，学习。这样，每个人都可以学到优秀的课程。目前中国的大学是有互联互通的教育网的，国家互联网也几乎已经通到各个地区，因此实现此想法的基础设施已经具备。我一直相信科技能够改变生活，科技应该为人类过上更加美好的生活服务，合适的利用科技的发展可以促进教育更加公平。</p>
<p>目前很多学校已经对优秀的课程进行录播了，像北大的公开课，还有各个大学和网易合作的公开课等，但是互联互通，公益性，课程的全面性，都做的不好。</p>
<p>我想象有这样的未来，不管你身处何处，只要是中华人民共和国国民，就可以像她的宪法和教育法中说的那样，有公平的受教育的机会，有终身学习的良好条件，可以得到全面发展，摆脱愚昧和无知，做一个幸福的人。</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>写个图床软件叫“简图”</title>
    <url>/2020/06/02/%E5%86%99%E4%B8%AA%E5%9B%BE%E5%BA%8A%E8%BD%AF%E4%BB%B6%E5%8F%AB%E2%80%9C%E7%AE%80%E5%9B%BE%E2%80%9D/</url>
    <content><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>我使用<code>MarkDown+Github+PicGo</code>三件套写博客，使用<code>PicGo</code>的时候发现自己有上传手机图片的场景，但是<code>PicGo</code>并没有iOS版本的客户端。我在AppStore经过搜索，发现并没有合适的支持Github图床的App，因此便想着写一个。</p>
<a id="more"></a>
<h2 id="期待"><a href="#期待" class="headerlink" title="期待"></a>期待</h2><p>今天写这个主要是先把我的想法给记录一下，以防忘了这个事儿了。也简单写一下我期望的这个App的功能：</p>
<h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ol>
<li>支持各种图床。首先适配Github图床，再慢慢添加其他图床。</li>
<li>支持历史记录，历史记录本地保存或者保存到iCloud。</li>
<li>纯工具应用，无账号系统。</li>
<li>尽量对标PicGo，该有的功能都要有。</li>
</ol>
<h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><p>关于这个App的名字，我想了很久一直没有想好。今天突然想到一个不错的名字：<strong>简图</strong>，是<code>简单图床</code>的缩写，英文就叫<code>Easy Picture Bed</code>或者使用缩写<code>EPB</code>。<br>之所以这么命名，是因为我做这个App的目的就是为了图片上传图床变成一个简单的事。</p>
<h4 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h4><p>最近比较上班比较忙，晚上还要做一些技术学习，因此开发这个App可能比较慢。具体的规划目前还没有，等空下来开始做了就快了。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p><a href="https://github.com/Molunerfinn/PicGo">PicGo</a>是一个快速上传图片并获取图片URL链接的工具。支持Mac，Windows电脑。</p>
<blockquote>
<p>支持：<br>七牛图床<br>腾讯云<br>又拍云<br>Github<br>阿里云<br>Imgur</p>
</blockquote>
]]></content>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>去海边跳来跳去</title>
    <url>/2020/08/26/%E5%8E%BB%E6%B5%B7%E8%BE%B9%E8%B7%B3%E6%9D%A5%E8%B7%B3%E5%8E%BB/</url>
    <content><![CDATA[<p>用了两天的空闲时间，看了是枝裕和导演的《小偷家族》。</p>
<p>剧中讲述的是一个生活在底层的一个“小偷家庭”的故事。家庭之中有弟弟祥太，妹妹百合，姐姐亚纪，父亲母亲，还有奶奶组成。家庭的生活的开支靠打零工和偷东西维持。这个看似完整的家庭，各个成员之间却没有什么血缘关系。</p>
<p>妹妹百合饱受原生家庭的虐待，在一个冬夜被“父亲”柴田治发现后，带到家中。百合在这个家庭中，慢慢的找回幸福，慢慢的感受到爱，然后融入到这个充满快乐的家庭。</p>
<p>刚才不小心看到一个影评，和我想写的一样。嗯，就写到这吧。</p>
]]></content>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title>在屏幕中间显示字符串</title>
    <url>/2020/06/21/%E5%9C%A8%E5%B1%8F%E5%B9%95%E4%B8%AD%E9%97%B4%E6%98%BE%E7%A4%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>8086汇编中有一道编程题，今天花了两个小时做完了，这里记录一下做的过程</p>
<p>题目是这样的:</p>
<blockquote>
<p>在屏幕中间分别显示绿色、绿底红色、白底蓝色的字符串’welcome to masm!’</p>
</blockquote>
<a id="more"></a>

<p>内存空间地址中,地址：B8000h ~ b8f9fh为显示缓存区，显示缓存区8页，每页总共25行，80个字符，每个字符占一个字，通常显示第一页，</p>
<p>屏幕中间：为12 13 14行，偏移量的计算公式就为：<code>(160 * (行数 - 1))</code>，那么：</p>
<p>12行对应6e0 ~ 77f </p>
<p>13行对应780 ~ 81f </p>
<p>14行对应820 ~ 8bf</p>
<p>而根据属性字节的公式：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">        <span class="number">7</span>    <span class="number">6</span>    <span class="number">5</span>    <span class="number">4</span>    <span class="number">3</span>    <span class="number">2</span>    <span class="number">1</span>    <span class="number">0</span></span><br><span class="line">含义：  (BL) (R    G    B)  (I)  (R    G    B)</span><br><span class="line">       闪烁      背景        高亮      前景</span><br></pre></td></tr></table></figure>

<p>题目中三种颜色的属性字节应为：</p>
<p>绿色：             00000010b，十六进制为02h </p>
<p>绿底红色：     00100100b ，十六进制为24h </p>
<p>白底蓝色:        01110001b ，十六进制为71h</p>
<p>显示字符：welcome to masm! 共16个字， 因为有80个字，那么第33~48个字在中间。偏移量为：66 ~ 96</p>
<p>分析后有以下程序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">     db &#39;welcome to masm!&#39;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">color segment</span><br><span class="line">     db 02h,24h,71h</span><br><span class="line">color ends </span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:  mov ax,data</span><br><span class="line">        mov ds,ax</span><br><span class="line"></span><br><span class="line">        mov ax,0b86eh</span><br><span class="line">        mov es,ax</span><br><span class="line"></span><br><span class="line">        mov si,0</span><br><span class="line">        mov cx,3</span><br><span class="line">        mov di,0</span><br><span class="line"></span><br><span class="line">s0:     push cx</span><br><span class="line"></span><br><span class="line">        mov bx,0</span><br><span class="line">        mov bp,0</span><br><span class="line"></span><br><span class="line">        mov cx,16</span><br><span class="line">s1:</span><br><span class="line">        mov al,ds:[bx]</span><br><span class="line">        mov es:[bp+si+66],al</span><br><span class="line">        inc bp</span><br><span class="line">        inc bx</span><br><span class="line"></span><br><span class="line">        push ds</span><br><span class="line">        mov ax,color</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov al,ds:[di]</span><br><span class="line">        mov es:[bp+si+66],al</span><br><span class="line">        pop ds </span><br><span class="line"></span><br><span class="line">        inc bp</span><br><span class="line">        loop s1</span><br><span class="line"></span><br><span class="line">        add si,0a0h</span><br><span class="line">        inc di</span><br><span class="line"></span><br><span class="line">        pop cx</span><br><span class="line">        loop s0</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>如何做一个CALayer 自定义属性CAAnimation动画</title>
    <url>/2018/12/27/%E5%A6%82%E4%BD%95%E5%81%9A%E4%B8%80%E4%B8%AACALayer-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7CAAnimation%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<p>最近在做CALayer自定义属性(<code>@property</code>修饰)动画。之前没有深究过，现在有很多有意思的发现，写出来分享给大家。</p>
<p>首先把<a href="https://github.com/lengain/LNLoadingLayer">Demo LNLoadingLayer</a>分享给大家，这是一个loading动画。</p>
<p>在做CALayer自定义属性动画之前，要先了解一个概念，即CALayer是一个<code>符合键值编码的容器类（Key-Value Coding Compliant Container Classes）</code>。</p>
<h4 id="符合键值编码的容器类"><a href="#符合键值编码的容器类" class="headerlink" title="符合键值编码的容器类"></a>符合键值编码的容器类</h4><p>CALayer和CAAnimation都是符合键值编码的容器类（Key-Value Coding Compliant Container Classes），</p>
<p>这意味着你可以用任意<code>key</code>来设置值，即使这个<code>key</code>没有声明为CALayer的property。</p>
<a id="more"></a>

<p>以下是苹果<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/Key-ValueCodingExtensions/Key-ValueCodingExtensions.html#//apple_ref/doc/uid/TP40004514-CH12-SW2">Core Animation 编程指南</a>的介绍：</p>
<blockquote>
<p>The<a href="https://developer.apple.com/documentation/quartzcore/caanimation">CAAnimation</a>and<a href="https://developer.apple.com/documentation/quartzcore/calayer">CALayer</a> classes are key-value coding compliant container classes, which means that you can set values for arbitrary keys. Even if the key<code>someKey</code>is not a declared property of the<code>CALayer</code>class, you can still set a value for it as follows:</p>
<p>[ theLayer setValue:[NSNumber numberWithInteger:50] forKey:@”someKey”];</p>
<p>You can also retrieve the value for arbitrary keys like you would retrieve the value for other key paths. For example, to retrieve the value of the<code>someKey</code>path set previously, you would use the following code:</p>
<p>someKeyValue = [theLayer valueForKey:@”someKey”];</p>
</blockquote>
<p>因此，在CALayer中，用@dynamic修饰的属性，即使没有实现setter getter也不会崩溃。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DynamicTest</span> : <span class="title">CALayer</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *title;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DynamicTest</span></span></span><br><span class="line"><span class="keyword">@dynamic</span> title;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">DynamicTest *test = [[DynamicTest alloc] init];</span><br><span class="line">test.title = <span class="string">@&quot;title&quot;</span>;<span class="comment">//正常工作，不会崩溃。</span></span><br><span class="line"><span class="comment">//另外，CALayer和CAAnimation，会自动为@dynamic修饰的属性添加NSCoding协议的支持。不用@dynamic修饰，则不支持。</span></span><br><span class="line"><span class="built_in">NSData</span> *data = [<span class="built_in">NSKeyedArchiver</span> archivedDataWithRootObject:test];</span><br><span class="line">DynamicTest *unarchiveTest = [<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithData:data];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;unarchiveTest.title=%@&quot;</span>,unarchiveTest.title);</span><br><span class="line"><span class="comment">//输出 unarchiveTest.title=title</span></span><br></pre></td></tr></table></figure>

<h4 id="dynamic在CALayer中的特殊表现"><a href="#dynamic在CALayer中的特殊表现" class="headerlink" title="@dynamic在CALayer中的特殊表现"></a>@dynamic在CALayer中的特殊表现</h4><p>CALayer中，用@synthesize修饰的属性，可以正常使用getter/setter，而@dynamic修饰的属性，也可以实现getter/setter。但是<strong>在自定义属性动画时，就必须使用@dynamic修饰</strong>，因为<code>Core Animation</code>框架对@dynamic修饰的的属性做了一些特殊操作，使得CALayer能够在监控到属性变化时，调用相应的方法，实现动画。</p>
<p>这个特殊操作，我目前没有查到，如果谁知道，可以联系我告知一下，我给补上。多谢。</p>
<h4 id="id-initWithLayer-id-layer方法"><a href="#id-initWithLayer-id-layer方法" class="headerlink" title="-(id)initWithLayer:(id)layer方法"></a>-(id)initWithLayer:(id)layer方法</h4><p>我们知道，所谓动画，只不过是一帧帧静止的图片，以一定的速度（比如每秒60张）连续播放，肉眼因为视觉残象产生错觉，便以为画面是活动的。</p>
<p>Core Animation动画也是这个原理，在Core Animation动画过程中，不断的有副本图层（或表示图层<code>copied-layer</code> or <code>presentation layer</code>）被初始化，连续播放，形成动画。<code>-initWithLayer:</code>就是Core Animation为CALayer创建副本对象的初始化方法。</p>
<p><strong>注意：</strong></p>
<p>1.此方法会被自动调用。</p>
<p>2.@dynamic修饰的属性，<code>-initWithLayer:</code>后会被自动复制给副本Layer。方法中必须调用<code>[super initWithLayer:layer]</code></p>
<p>3.@synthesize修饰或不加修饰词的@property属性，需要重写<code>-initWithLayer:</code>方法，手动将属性赋值给副本对象。如果没有这样的属性，或属性不影响显示，此方法不重写也可以。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This initializer is used by CoreAnimation to create shadow copies of</span></span><br><span class="line"><span class="comment"> * layers, e.g. for use as presentation layers. Subclasses can override</span></span><br><span class="line"><span class="comment"> * this method to copy their instance variables into the presentation</span></span><br><span class="line"><span class="comment"> * layer (subclasses should call the superclass afterwards). Calling this</span></span><br><span class="line"><span class="comment"> * method in any other situation will result in undefined behavior. */</span></span><br><span class="line">-(<span class="keyword">id</span>)initWithLayer:(<span class="keyword">id</span>)layer &#123;    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> initWithLayer:layer]) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([layer isKindOfClass:[<span class="built_in">CGCustomPropertyLayer</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            <span class="built_in">CGCustomPropertyLayer</span> *cpLayer = layer;</span><br><span class="line">            <span class="comment">// Copy across ...</span></span><br><span class="line">            <span class="keyword">self</span>.nonDynamicProperty = cpLayer.nonDynamicProperty;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="现在开始自定义属性动画"><a href="#现在开始自定义属性动画" class="headerlink" title="现在开始自定义属性动画"></a>现在开始自定义属性动画</h4><p>在添加过自定义属性后，设置一下@dynamic，如果还有额外的属性，记得重写<code>-initWithLayer:</code>。</p>
<p>接下来要添加一个很重要的类方法<code>+needsDisplayForKey:</code></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Layer初次加载时，会调用此方法，用来判断属性的值改变时，是否需要重新绘制。因此自定义属性动画必须实现此方法且返回YES</span></span><br><span class="line"><span class="comment">//实现此方法后，自定义属性的值一旦改变,便会自动调用setNeedsDisplay，触发重绘。</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)needsDisplayForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">return</span> [key isEqualToString:CustomPropertyName] ? <span class="literal">YES</span> : [<span class="keyword">super</span> needsDisplayForKey:key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，就可以写绘制的代码了，绘制时，一般写在<code>drawInContext:</code>或<code>drawLayer: inContext:</code>方法之中，当然，也可以写在<code>display</code>方法之中，但是应注意和CALayer的delegate是否会冲突。</p>
<blockquote>
<p>layer方法响应链有两种:</p>
<ol>
<li><p>[layer setNeedDisplay] -&gt; [layer displayIfNeed] -&gt; [layer display] -&gt; [layerDelegate displayLayer:]</p>
</li>
<li><p>[layer setNeedDisplay] -&gt; [layer displayIfNeed] -&gt; [layer display] -&gt; [layer drawInContext:] -&gt; [layerDelegate drawLayer: inContext:]</p>
<p>如果layerDelegate实现了displayLayer:协议，之后layer就不会再调用自身的重绘代码</p>
</li>
</ol>
</blockquote>
<p><a href="https://github.com/lengain/LNLoadingLayer/blob/master/LNLoadingLayer/LNLoadingExplicitLayer.m">示例代码</a>写在<code>drawInContext:</code>中。</p>
<p><strong>注意</strong>：绘制的CALayer图形，在默认情况下，会很糊，因此使用时要设置<code>layer.contentsScale = [UIScreen mainScreen].scale;</code>contentsScale属性，默认为1.</p>
<p>绘制代码完成后，就可以使用动画了，添加<a href="https://github.com/lengain/LNLoadingLayer/blob/master/LNLoadingLayer/ViewController.m">动画代码</a></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">LNLoadingExplicitLayer *loadingLayer = [[LNLoadingExplicitLayer alloc] init];</span><br><span class="line">loadingLayer.frame = frame;</span><br><span class="line">loadingLayer.progressLineWidth = <span class="number">6.</span>f/[<span class="built_in">UIScreen</span> mainScreen].scale;</span><br><span class="line">loadingLayer.contentsScale = [<span class="built_in">UIScreen</span> mainScreen].scale;</span><br><span class="line">[<span class="keyword">self</span>.view.layer addSublayer:loadingLayer];</span><br><span class="line"></span><br><span class="line"><span class="built_in">CABasicAnimation</span> *animation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@&quot;progress&quot;</span>];</span><br><span class="line">animation.fromValue = @(<span class="number">0</span>);</span><br><span class="line">animation.toValue = @(<span class="number">200</span>);</span><br><span class="line">animation.duration = <span class="number">2.0</span>;</span><br><span class="line">animation.repeatCount = MAXFLOAT;</span><br><span class="line">animation.timingFunction = [<span class="built_in">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionLinear];</span><br><span class="line">[loadingLayer addAnimation:animation forKey:<span class="string">@&quot;progressKey&quot;</span>];;</span><br></pre></td></tr></table></figure>

<p>此时，自定义属性动画已经可以动起来了。</p>
<p>下面来介绍隐式动画。</p>
<h4 id="隐式动画（implicit-animation）"><a href="#隐式动画（implicit-animation）" class="headerlink" title="隐式动画（implicit animation）"></a>隐式动画（implicit animation）</h4><p>没有指定任何动画类型的动画叫隐式动画。即属性平滑过渡到新的值的默认行为。</p>
<p>在demo的<code>LNLoadingExplicitLayer</code>类中，只实现了基本的显式动画。当我们想要在改变属性值自动有个过渡动画时，便要再添加一个方法<code>actionForKey:</code> ,这里是<a href="https://github.com/lengain/LNLoadingLayer/blob/master/LNLoadingLayer/LNLoadingLayer.m">示例代码</a>，当layer属性改变时，layer都会寻找合适的action来实行这个改变，<code>actionForKey:</code>便是指定属性默认隐式动画的方法。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)actionForKey:(<span class="built_in">NSString</span> *)event &#123;</span><br><span class="line">    <span class="keyword">if</span> ([event isEqualToString:LNProgressKey]) &#123;</span><br><span class="line">        <span class="built_in">CABasicAnimation</span> *actionAnimation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:CustomPropertyName];</span><br><span class="line">        actionAnimation.timingFunction = [<span class="built_in">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionLinear];</span><br><span class="line">        actionAnimation.fromValue = @(<span class="keyword">self</span>.progress);</span><br><span class="line">        <span class="keyword">return</span> actionAnimation;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> actionForKey:event];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="http://sindrilin.com/2017/12/14/bottleeneck_of_transacation.html">这里</a>有一个介绍隐式动画很好的博文，感兴趣可以看看。更多内容可以搜索iOS隐式动画。</p>
<p>谢谢观看！</p>
<p>参考：</p>
<p>1.<a href="https://gist.github.com/toriaezunama/9174945#file-core-animation-of-custom-properties">Core animation of custom properties</a><br>2.<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/Key-ValueCodingExtensions/Key-ValueCodingExtensions.html#//apple_ref/doc/uid/TP40004514-CH12-SW2">Core Animation 编程指南</a></p>
<p>3.<a href="https://www.objc.io/issues/12-animations/animating-custom-layer-properties/">Animating Custom Layer Properties</a></p>
<p>4.<a href="https://blog.csdn.net/sinat_27706697/article/details/49738957">https://blog.csdn.net/sinat_27706697/article/details/49738957</a></p>
]]></content>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>如何安装iOS 13 beta版</title>
    <url>/2019/06/14/%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85iOS-13-beta%E7%89%88/</url>
    <content><![CDATA[<p>最近，<a href="https://www.apple.com/cn/newsroom/2019/06/apple-previews-ios-13/">Apple发布iOS 13 预览版</a> 支持深色模式，优化了照片与相机功能，还有输入法的升级等。</p>
<p>想尝鲜的同学可以参考本文进行升级。苹果系统每个版本的前几个beta版，都会有很多bug，因此心里面要有准备。如果想要新系统的开发做出贡献，可以使用Feedback反馈自己使用中遇到的bug，Feedback会在新系统安装后自动出现。</p>
<p>升级前，请参照如下表格，查看机型是否支持新系统的安装。也可以去官网查看<a href="https://developer.apple.com/download/#ios-restore-images-ipad-new">苹果开发者官网</a></p>
<table>
<thead>
<tr>
<th align="center">iOS</th>
<th align="center">iPad OS</th>
</tr>
</thead>
<tbody><tr>
<td align="center">iPhone XS/XS Max</td>
<td align="center">iPad Pro 12.9-inch/9.7-inch</td>
</tr>
<tr>
<td align="center">iPhone XR</td>
<td align="center">iPad Pro 10.5-inch</td>
</tr>
<tr>
<td align="center">iPhone X</td>
<td align="center">iPad Pro 12.9-inch 2nd/3rd</td>
</tr>
<tr>
<td align="center">iPhone 8/8 Plus</td>
<td align="center">iPad Pro 11-inch</td>
</tr>
<tr>
<td align="center">iPhone 7/7 Plus</td>
<td align="center">iPad Mini 4/5th</td>
</tr>
<tr>
<td align="center">iPhone 6s/6s Plus</td>
<td align="center">iPad 5th/6th</td>
</tr>
<tr>
<td align="center">iPhone SE</td>
<td align="center">iPad Air 2/3rd</td>
</tr>
<tr>
<td align="center">iPod touch (7th generation)</td>
<td align="center"></td>
</tr>
</tbody></table>
<a id="more"></a>

<h5 id="升级前准备"><a href="#升级前准备" class="headerlink" title="升级前准备"></a>升级前准备</h5><p>升级需要Mac电脑，以及符合上表中列出的设备。</p>
<p>目前iOS13 Beta版还不支持使用OTA 文件辅助安装，因此只能手动下载安装包手动安装。</p>
<h6 id="1-首先备份自己的设备数据。"><a href="#1-首先备份自己的设备数据。" class="headerlink" title="1.首先备份自己的设备数据。"></a>1.首先备份自己的设备数据。</h6><p>任何时候，数据保护是最重要的。因此，在升级之前，务必先备份自己的设备。</p>
<h6 id="2-去苹果开发者官网下载与手机对应的安装包"><a href="#2-去苹果开发者官网下载与手机对应的安装包" class="headerlink" title="2.去苹果开发者官网下载与手机对应的安装包"></a>2.去<a href="%5Bhttps://developer.apple.com/download/#ios-restore-images-ipad-new%5D(https://developer.apple.com/download/#ios-restore-images-ipad-new">苹果开发者官网</a>下载与手机对应的安装包</h6><h5 id="升级安装"><a href="#升级安装" class="headerlink" title="升级安装"></a>升级安装</h5><p>安装之前，首先要升级Mac安装环境，目前有三种途径，以下任何一种都可以。</p>
<ol start="2">
<li><p>安装MacOS 10.15 Catalina beta</p>
</li>
<li><p>安装Xcode 11 beta，打开并安装好component</p>
</li>
<li><p>下载并安装<a href="%5Bhttp://alirezakhoddam.com/wwdc19/MobileDevice.pkg%5D(http://alirezakhoddam.com/wwdc19/MobileDevice.pkg">MobileDevice.pkg</a>，如果安装前已打开iTunes，请重启以下iTunes。</p>
</li>
</ol>
<p>我使用的是第三种方法。</p>
<p>然后打开 iTunes，把 iPhone / iPad 连接到 Mac，按住 Option，同时点击「检查更新」，选择下载好的固件，点击打开，进行安装。</p>
<h5 id="恢复到iOS12"><a href="#恢复到iOS12" class="headerlink" title="恢复到iOS12"></a>恢复到iOS12</h5><p>下载最新的<a href="https://developer.apple.com/download/release/">iOS12系统固件</a>，然后用上面的安装步骤，使用iTunes进行安装即可。如果数据损坏，可以用之前的备份，进行恢复。</p>
]]></content>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>封装一个超级易用的Swift网络请求库</title>
    <url>/2024/03/11/%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E8%B6%85%E7%BA%A7%E6%98%93%E7%94%A8%E7%9A%84Swift%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%BA%93/</url>
    <content><![CDATA[<p>Swift网络库最著名的就是<code>Alamofire</code>,但是在实际项目中，想要尽可能简单的发起网络请求，必须对<code>Alamofire</code>进行一层封装。依赖<code>Alamofire</code>的封装库也有很多优秀的，比如<code>Moya</code>。但是经过项目的使用，我发现<code>Moya</code>用起来并不简单，它有以下问题：</p>
<ul>
<li>硬编码较多<br>Moya使用时要在指定的方法中添加请求方法，请求参数，路径。</li>
<li>封装复杂<br><code>Alamofire</code>已经是一个功能繁多的网络库了，<code>Moya</code>的二次封装，既要保证功能完整，又要使用面向协议，导致了过多的抽象，用户在使用时，大都需要三次业务的封装，虽然也面向协议了，但却复杂了。</li>
</ul>
<p>因此对于众多中小项目而言，笔者觉得<code>Moya</code>并不是一个合适的选项。合适的网络库，应该是对基础库（Alamofire）的精简，保证既简单易用，又有灵活的扩展性。</p>
<p>那发起的请求，要简化到什么程度？<br>只需指定<code>参数</code>和<code>路径</code>，就可以发起请求，最好使用<code>类方法</code>，来直接发起请求。<br>而简化的越彻底，其他地方要做的就越多，因此，通常情况下，也要设计出以下功能：</p>
<ul>
<li>统一设置公共参数</li>
<li>统一设置请求头</li>
<li>统一的设置加载指示器</li>
<li>统一解析数据</li>
<li>等等</li>
</ul>
<p>我根据以上要求，花了两天的空闲时间，写了一个轻量级的网络库<a href="https://github.com/lengain/LightNetwork">LightNetwork</a>，抛砖引玉。<br>该库使用面向对象的封装逻辑，下面是它的介绍。</p>
<h2 id="发起请求"><a href="#发起请求" class="headerlink" title="发起请求"></a>发起请求</h2><p>比如发起一个修改用户名的请求，外部暴露参数userName即可，方法内部指定path和parameter。调用时直接使用类方法调用。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleRequest</span> : <span class="title">ExampleBaseRequest</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">modify</span>(<span class="title">userName</span>:<span class="title">String</span>,<span class="title">success</span>: @<span class="title">escaping</span> <span class="title">LNRequestSuccess</span>, <span class="title">failure</span>:@<span class="title">escaping</span> <span class="title">LNRequestFailure</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">self</span>.post(path: <span class="string">&quot;/modify&quot;</span>, parameters: [<span class="string">&quot;userName&quot;</span>:userName], success: success, failure: failure)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//use</span></span><br><span class="line"><span class="type">ExampleRequest</span>.modify(userName: <span class="string">&quot;Light&quot;</span>) &#123; request, responseData <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Success:\(responseData)&quot;</span>)</span><br><span class="line">&#125; failure: &#123; request, errorDescription <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Failure:\(errorDescription)&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果觉得统一管理URL更好，也可以使用静态字符串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct URLPath &#123;</span><br><span class="line">    static let query : String &#x3D; &quot;&#x2F;query&quot;</span><br><span class="line">    static let goods : String &#x3D; &quot;&#x2F;goods&quot;</span><br><span class="line">    static let modify : String &#x3D; &quot;&#x2F;modify&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class func modify(userName:String,success: @escaping LNRequestSuccess, failure:@escaping LNRequestFailure) &#123;</span><br><span class="line">    self.post(path: URLPath.modify, parameters: [&quot;userName&quot;:userName], success: success, failure: failure)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h2><p>设置BaseURL：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> config = <span class="type">LNNetworkConfiguration</span>(baseURL: <span class="type">URL</span>(string: <span class="string">&quot;https://example.com/&quot;</span>))</span><br><span class="line">config.networkInterceptor = <span class="type">ExampleLightInterceptor</span>.<span class="keyword">init</span>()</span><br><span class="line"><span class="type">LNNetworkManager</span>.<span class="keyword">default</span>.configuration = config</span><br></pre></td></tr></table></figure>

<p>其中<code>config.networkInterceptor</code>是对所有网络请求的拦截器，可在拦截器中统一的添加参数，请求头。<br>配置全局拦截器：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleLightInterceptor</span>: <span class="title">LNNetworkInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 添加公共参数</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">interceptor</span><span class="params">(<span class="keyword">_</span> request: LNBaseRequest, parameter: Parameters?)</span></span> -&gt; <span class="type">Parameters?</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> para : <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">Any</span>&gt; = parameter ?? <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">Any</span>&gt;.<span class="keyword">init</span>()</span><br><span class="line">        para[<span class="string">&quot;public&quot;</span>] = <span class="string">&quot;test&quot;</span></span><br><span class="line">        <span class="keyword">return</span> para</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// 添加公共请求头</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">interceptor</span><span class="params">(<span class="keyword">_</span> request: LNBaseRequest, headerFields: Alamofire.HTTPHeaders?)</span></span> -&gt; <span class="type">Alamofire</span>.<span class="type">HTTPHeaders?</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> header = <span class="type">HTTPHeaders</span>();</span><br><span class="line">        headerFields?.dictionary.forEach &#123; header.add(name: $<span class="number">0</span>.key, value: $<span class="number">0</span>.value) &#125;</span><br><span class="line">        header.add(name: <span class="string">&quot;publicHeader&quot;</span>, value: <span class="string">&quot;test&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> header</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//请求开始。可配置显示加载指示器</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">interceptor</span><span class="params">(start request: LNBaseRequest)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Request start: \(request.url)&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//请求结束。可配置隐藏加载指示器</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">interceptor</span><span class="params">(end request: LNBaseRequest)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Request end: \(request.url)&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置统一的响应处理</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleBaseRequest</span>: <span class="title">LNRequest</span> </span>&#123;</span><br><span class="line">   <span class="comment">//自定义error code，并使用LNRequestFailure返回</span></span><br><span class="line">    <span class="keyword">var</span> errorCode : <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> responseData : <span class="type">Any?</span></span><br><span class="line">    <span class="comment">// 自定义统一处理响应结果</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(response: AFDataResponse&lt;Data?&gt;, success: LNRequestSuccess?, failure: LNRequestFailure? = <span class="literal">nil</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> response.result &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> .success(data):</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> sourceData = data <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> jsonData = <span class="keyword">try</span> <span class="type">JSONSerialization</span>.jsonObject(with: sourceData, options: .allowFragments)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> code : <span class="type">Int</span> = (jsonData <span class="keyword">as</span>! [<span class="type">String</span> : <span class="type">Any</span>])[<span class="string">&quot;code&quot;</span>] <span class="keyword">as</span>! <span class="type">Int</span></span><br><span class="line">                <span class="keyword">if</span> code == <span class="number">200</span> &#123;</span><br><span class="line">                    success?(<span class="keyword">self</span>, jsonData)</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    failure?(<span class="keyword">self</span>, <span class="type">ExampleServerError</span>.invalidParameter)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> error = <span class="type">AFError</span>.responseSerializationFailed(reason: .jsonSerializationFailed(error: error))</span><br><span class="line">                failure?(<span class="keyword">self</span>, error)</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> .failure(error):</span><br><span class="line">            failure?(<span class="keyword">self</span>, error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过上述的配置，基本上满足的日常网络请求的需要，同时支持很方便的下载，上传，进度监控，设置缓存逻辑，超时时长等。详细的配置可以参考<a href="https://github.com/lengain/ExampleForLightNetwork">示例代码</a>.</p>
<h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>LightNetwork中的请求方法，本身就是调用Alamofire的请求方法，LightNetwork所做的只是Alamofire多参数的方法进行类化。即将Alamofire请求方法的参数，写成LightNetwork LNBaseRequest类的属性，这样即方便了统一配置，也便于Alamofire方法的简化。同时，返回参数保持和Alamofire一致，保留了Alamofire方法的链式调用。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Alamofire</span></span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">request</span><span class="params">(<span class="keyword">_</span> convertible: URLConvertible,</span></span></span><br><span class="line"><span class="function"><span class="params">                      method: HTTPMethod = .<span class="keyword">get</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                      parameters: Parameters? = <span class="literal">nil</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                      encoding: ParameterEncoding = URLEncoding.<span class="keyword">default</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                      headers: HTTPHeaders? = <span class="literal">nil</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                      interceptor: RequestInterceptor? = <span class="literal">nil</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                      requestModifier: RequestModifier? = <span class="literal">nil</span>)</span></span> </span><br><span class="line">-&gt; <span class="type">DataRequest</span></span><br><span class="line"><span class="comment">//LightNetwork</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">LNBaseRequest</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> path: <span class="type">String</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> method: <span class="type">HTTPMethod</span> = .<span class="keyword">get</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> parameters: <span class="type">Parameters?</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> encoding: <span class="type">ParameterEncoding</span> = <span class="type">URLEncoding</span>.<span class="keyword">default</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> headers: <span class="type">HTTPHeaders?</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> interceptor: <span class="type">RequestInterceptor?</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> requestModifier: <span class="type">Alamofire</span>.<span class="type">Session</span>.<span class="type">RequestModifier?</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> cachePolicy: <span class="type">URLRequest</span>.<span class="type">CachePolicy</span> = .useProtocolCachePolicy</span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> timeoutInterval: <span class="type">TimeInterval</span> = <span class="number">60</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">request</span>(<span class="title">path</span>: <span class="title">String</span>,</span></span><br><span class="line"><span class="class">                     <span class="title">method</span>: <span class="title">HTTPMethod</span> = .<span class="title">get</span>, </span></span><br><span class="line"><span class="class">                     <span class="title">parameters</span>: <span class="title">Parameters</span>? = <span class="title">nil</span>, </span></span><br><span class="line"><span class="class">                     <span class="title">success</span>: <span class="title">LNRequestSuccess</span>?, </span></span><br><span class="line"><span class="class">                     <span class="title">failure</span>: <span class="title">LNRequestFailure</span>?) </span></span><br><span class="line"><span class="class">-&gt; <span class="title">DataRequest</span>? </span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>

<p>以上~</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>我的博客</title>
    <url>/2018/12/25/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>上段时间看一为博主的博客，名字忘了，但是觉得它的博客样式很不错，我看到他的博客是基于<a href="https://hexo.io/">Hexo</a>的，用的主题是<a href="https://github。com/litten/hexo-theme-yilia">Yilia</a>于是便有了我的新博客。</p>
<p>很早之前，我就开了<code>lengain.gitHub.io</code>这个博客，只是用着不方便，便没有维护进来。博客也写的不多，之前一直用简书，也写过一段时间的微信公众号，应该是写的不好，所以订阅量一直是身边的好友，没有多少读者。后来看到一首小诗，忘了名字和内容，但是根据那首小诗我想到一句话，就是”如果你想写作，就当做没有读者”。但凡你要表达自己的想法，最好的办法就是写出来。所以，我又又一次的决定，开始写起来。作为一个程序猿，还是觉得用自己的博客比较好。今日起，就转到这里吧，如果时间充裕的话，微信公众号我也会同步更新。</p>
<p>我是一个iOS开发者，博客里面免不了要发布一些技术文章。</p>
<p>我也是一个感性的人，也会把生活所感写到这里。</p>
<p>2018年就要过去了，希望2019不会太糟。</p>
]]></content>
  </entry>
  <entry>
    <title>换了一个新的网站图标</title>
    <url>/2023/08/18/%E6%8D%A2%E4%BA%86%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E7%BD%91%E7%AB%99%E5%9B%BE%E6%A0%87/</url>
    <content><![CDATA[<p>最近觉得之前的网站图标设计的太简陋，于是我设计了一个新图标，新图标是一个背着的大熊猫图案，灵感来自于背着人们吃竹子的熊猫。通过新图标，我想表达的是一只大熊猫，坐在那里，独自思考的场景，对于这个博客，这个图标比较契合。</p>
<p><img src="/2023/08/18/%E6%8D%A2%E4%BA%86%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E7%BD%91%E7%AB%99%E5%9B%BE%E6%A0%87/icon.png" alt></p>
<p>前几年，简单图床发布之后，反映了了，于是我基本上放弃了维护，因为没有来自独立软件的收入，我的开发者账号也没有在续费了。因此软件也自动下架了。</p>
<p>通过此事我也学到了一些小小经验：</p>
<ul>
<li><p>要明白软件的目的是为了服务用户</p>
</li>
<li><p>运营很重要</p>
</li>
<li><p>软件收入很重要，即使开个赠个咖啡的入口也行</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>攒个机</title>
    <url>/2020/10/05/%E6%94%92%E4%B8%AA%E6%9C%BA/</url>
    <content><![CDATA[<p><strong>2020-10-05</strong></p>
<p>双十一准备攒一台主机。</p>
<p>CPU准备选十代i7k。以下配置都是按照该CPU来配置的。选配的理念是高性能，静音，无灯光。这个配置未来5年够躁的了。</p>
<a id="more"></a>

<p>CPU：英特尔十代酷睿i7-10700K 八核 x1</p>
<p>主板：华硕ROG STRIX Z490-A GAMING x1</p>
<p>内存：台式机三星DDR4 16G 3200MHz  x2</p>
<p>硬盘：三星 970EVO PLUS 1TB 固态</p>
<p>显卡：索泰 RTX2060-6GD6 PLUS OC x1</p>
<p>显示器：AOC 27寸 4k 高清屏 x1</p>
<p>机箱：先马 黑洞 台式电脑静音机箱 x1</p>
<p>电源：长城HOPE 7000DS 600w x1</p>
<p><strong>2020-11-14</strong></p>
<p>后来和磊商议之后，他建议我降低电脑配置，配一台性能不拖后腿，静音，无灯光的机器。我想了想确实够用最好，没必要追求花里胡哨的，便改为下面的配置：</p>
<p>CPU：英特尔十代酷睿i7-10700 八核 x1</p>
<p>主板：微星迫击炮B460M 无WiFi</p>
<p>内存：美商海盗船DDR4 16G 3000MHz x2</p>
<p>硬盘：三星 970EVO PLUS 1TB 固态</p>
<p>显卡：索泰 RTX2060 Super 霹雳版 x1</p>
<p>显示器：优派 VX2780-4k-hd 27寸 高清屏 x1</p>
<p>机箱：爱国者 黑曼巴 台式电脑静音机箱 x1</p>
<p>电源：美商海盗船 650w电源 x1</p>
<p>这个配置相比之前的配置，降低了CPU 频率，超频也都舍弃了，提升了显示器，电源，显卡。</p>
<p>下面是跑分图：</p>
<p><img src="/2020/10/05/%E6%94%92%E4%B8%AA%E6%9C%BA/%E8%B7%91%E5%88%86%E5%9B%BE.jpg" alt="跑分图"></p>
<p>今年双十一从十一月一号开始，在10号之前我就陆陆续续收到了零件。全部到货后开始组装，我已经不是第一次组装电脑了，组装过程还算顺利，一次点亮。</p>
<p>使用体验也不错，4K的显示屏就是清晰，虽然相比MacBook Pro的屏幕还是差一点，但还是不错了。只有显卡这个没想到，噪音有点大。我这个人比较喜欢安静，整个主机的噪音来源大户就是显卡，还好之前买的就是静音机箱，里面有隔音棉，不运行大型程序时的噪音还能接受。</p>
]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>无题</title>
    <url>/2019/03/16/%E6%97%A0%E9%A2%98/</url>
    <content><![CDATA[<h3 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a>旅行</h3><p>&emsp;&emsp;去云南之前，我还想着租辆车，自驾游。后来去了泸沽湖才知道，自己完全低估了真正的山路有多难开。沿路来回400公里，是百分之百的山路。山路弯弯曲曲，爬坡下坡，感觉不出一公里，必有一个弯道。如此频繁的转弯，是对驾驶员严峻的考验，稍有不慎，就会车毁人亡，我是绝对受不了如此高强度的转弯，那是对心神的巨大消耗。</p>
<a id="more"></a>

<p>&emsp;&emsp;我是平原上长大的，你能想象绵延无尽的大山给我的震撼吗？之前有听说过<code>十万大山</code>这个词，而我在高铁上，汽车上，穿梭了这么久，眼前看到的还是大山，这里的地形，我觉得应该用百万大山，亿万大山来形容。</p>
<p>&emsp;&emsp;在绵延不绝的山路旁，不时会有散落的村庄，有时候，一座山上，才一户人家。就算一户人家，房子旁，还是会耸立着一个电线杆，也就是说，为了一户人家，国家电网也会把电线拉通。这时的我就在钦佩那些在电网事业奋斗的人，因为你们，每户人家都通了电。这也说明了国家电网的强大，同时也是国家的强大。</p>
<p>&emsp;&emsp;香格里拉最美的自然景观，当数巴拉格宗风景区，峡谷，河流，乱石，雪山，藏族人家，点缀其中，就像一个人间秘境。而在背后，<a href="https://baike.baidu.com/item/%E6%96%AF%E9%82%A3%E5%AE%9A%E7%8F%A0/22048649?fr=aladdin">斯那定珠</a>，这个推动巴拉格宗建设的人，也让我觉得敬佩不已。最美风景的那里，也会有最美的人。</p>
<h3 id="流浪地球"><a href="#流浪地球" class="headerlink" title="流浪地球"></a>流浪地球</h3><p>&emsp;&emsp;国产电影这是要崛起了，流浪地球真的很好看，墙裂推荐！！！</p>
<p>  小时候就喜欢科幻小说，初中的时候，我美霞姐送了我一本《海底两万里》，我欣喜的读了很久，被海底螺号的冒险和海底世界的美丽深深着迷。流浪地球则是人类带着地球，冲出了太阳系，飞向茫茫宇宙。而且流浪计划恢弘，旅行时间漫长，想象空间创作空间巨大，以后完全可以拍流浪地球二，三。</p>
<p>&emsp;&emsp;希望中国科幻片越来越好，中国电影越来越好，毕竟，我们也想做灯塔国。</p>
<h3 id="夏目友人帐"><a href="#夏目友人帐" class="headerlink" title="夏目友人帐"></a>夏目友人帐</h3><p>&emsp;&emsp;前几天，一个人跑去看了夏目友人帐电影版，讲的依旧是一个暖心的故事。我是去年开始看夏目友人帐的，这部动漫给我的最大的感触就是，在世界的各个角落，真的有那样一种人，他们不为挣钱，不为生活的忙碌所累，只为自己心中的所想，简简单单的在生活。这让我在杭州快节奏生活的缝隙中，在每天下班之后，心中能够有一丝平静。即使不做一个奋斗逼，也能心安理得，就是打打游戏看看电影</p>
<p>&emsp;&emsp;另一个感触就是漫画主人公夏目贵志，在他身边发生的点点滴滴，让我觉得，做一个善良的人，温暖的人，并不是什么可耻的漂亮话。努力做一个善良的人，温暖的人是真的很美好的事。</p>
<p>&emsp;&emsp;最近脾气不好，老是怼天怼地，愿我也有一天，也能够包容身边的好与不好，做个温暖的人，善良的人。</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编：显示字符串</title>
    <url>/2020/07/22/%E6%B1%87%E7%BC%96%EF%BC%9A%E6%98%BE%E7%A4%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>8086汇编中，有一道在屏幕上显示字符串的子程序。因为好久没做汇编题了，花了两个多小时，这里记录一下做的过程。<br>题目是这样的：</p>
<blockquote>
<p>显示字符串是现实工作中经常要用到的功能， 应该编写一个通用的子程序来实现这个功能。我们应该提供灵活的调用接口，使调用者可以决定显示的位置（行、列）、内容和颜色。<br>子程序描述<br>名称： show_str<br>功能： 在指定的位置，用指定的颜色，显示一个用0结束的字符串。<br>参数： （dh)＝ 行号（取值范围0<del>24), (di)＝ 列号（取值范围0</del>79)<br>(cl)＝颜色， ds:si指向字符串的首地址<br>返回： 无</p>
</blockquote>
<a id="more"></a>

<p>示例程序要求：在屏幕的8行3列， 用绿色显示data段中的字符串。<br>下面是我写的程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">        db &#39;Welcome to masm!&#39;,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:  mov dh,8</span><br><span class="line">        mov dl,3</span><br><span class="line">        mov cl,2</span><br><span class="line">        mov ax,data</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov si,0</span><br><span class="line">        call show_str</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">show_str:</span><br><span class="line">        push ax</span><br><span class="line">        push bx</span><br><span class="line">        push bp         ;bp用来读取显存中的偏移地址</span><br><span class="line">        push es         ;es用来读取显存中的起始地址</span><br><span class="line"></span><br><span class="line">        mov ax,0b800h</span><br><span class="line">        mov es,ax         ;将起始地址存入es</span><br><span class="line"></span><br><span class="line">        mov al,dh         ;显存偏移地址行号的偏移计算</span><br><span class="line">        mov ah,0</span><br><span class="line">        sub al,1</span><br><span class="line">        mov bl,0a0h</span><br><span class="line">        mul bl</span><br><span class="line">        mov bp,ax</span><br><span class="line"></span><br><span class="line">        mov ax,0         ;显存偏移地址列号的偏移计算</span><br><span class="line">        mov al,dl</span><br><span class="line">        mov bl,2</span><br><span class="line">        mul bl</span><br><span class="line">        add bp,ax        ;偏移地址都加到bp中</span><br><span class="line"></span><br><span class="line">s:      push cx</span><br><span class="line">        mov cl,[si]</span><br><span class="line">        mov ch,0</span><br><span class="line">        jcxz ok        ;根据0判断循环的结束。程序结束时需要pop cx</span><br><span class="line">        pop cx</span><br><span class="line">        mov al,[si]        ;低位存字母</span><br><span class="line">        mov ah,cl          ;高位存颜色</span><br><span class="line">        mov es:[bp],ax     ;设置到屏幕内存中</span><br><span class="line">        inc si</span><br><span class="line">        add bp,2</span><br><span class="line">        jmp short s</span><br><span class="line"></span><br><span class="line">ok:     pop cx          ;逐个pop用过寄存器</span><br><span class="line">        pop es</span><br><span class="line">        pop bp</span><br><span class="line">        pop bx</span><br><span class="line">        pop ax</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编：第一个课程设计</title>
    <url>/2020/07/28/%E6%B1%87%E7%BC%96%EF%BC%9A%E7%AC%AC%E4%B8%80%E4%B8%AA%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>这是王爽老师出版的《汇编语言》中第一个课程设计，做了一天多的时间。<br>题目描述经过我简化之后是这样的:</p>
<ul>
<li>data segment中存储了年份(db)，销售额(dd)，和人数(dw)，共21组数据;</li>
<li>table segment中初始化了21个字符串<code>year summ ne ??</code>，分别用来存储年份，销售额，人数，和平均销售额（销售额/人数，dw类型，商为整形，不考虑余数）</li>
<li>将data segment中的数据，填充到table segment中，并计算出平均销售额，然后显示在屏幕上。</li>
</ul>
<a id="more"></a>

<p>效果图如下：<br><img src="https://raw.githubusercontent.com/lengain/LengainGraphBed/master/picture/%E6%88%AA%E5%B1%8F2020-07-28%20%E4%B8%8B%E5%8D%884.38.08.png" width="300"><br>我的思路：</p>
<ul>
<li>大的循环为21次，使用dx表示循环的次数，行号=dx+1。</li>
<li>使用es:[bx]来对data进行寻址，使用ds:[si]来对table进行寻址。</li>
<li>分别复制年份，销售额，人数到table segment上。</li>
<li>计算平均销售额并填充到table segment上</li>
<li>利用cache segment来缓存显示到屏幕上的内容。写一个函数来显示cache中的内容，再写一个函数来清空cache中的内容。</li>
<li>年份可直接复制到cache中，显示出来。</li>
<li>销售额，人数，平均销售额为数字，使用dtoc函数，来转换数字为字符串，并存到cache中显示出来。</li>
</ul>
<p>以下是代码实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:codesg,ss:stacksg,ds:data </span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">        db &#39;1975&#39;,&#39;1976&#39;,&#39;1977&#39;,&#39;1978&#39;,&#39;1979&#39;,&#39;1980&#39;,&#39;1981&#39;,&#39;1982&#39;,&#39;1983&#39;</span><br><span class="line">        db &#39;1984&#39;,&#39;1985&#39;,&#39;1986&#39;,&#39;1987&#39;,&#39;1988&#39;,&#39;1989&#39;,&#39;1990&#39;,&#39;1991&#39;,&#39;1992&#39;</span><br><span class="line">        db &#39;1993&#39;,&#39;1994&#39;,&#39;1995&#39;</span><br><span class="line"></span><br><span class="line">        dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514</span><br><span class="line">        dd 34590,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000</span><br><span class="line"></span><br><span class="line">        dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226</span><br><span class="line">        dw 11542,14430,15257,17800</span><br><span class="line"></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">table segment</span><br><span class="line">        db 21 dup (&#39;year summ ne ?? &#39;)</span><br><span class="line">table ends</span><br><span class="line"></span><br><span class="line">cache segment       ;cache用来缓存显示在屏幕上的字符串</span><br><span class="line">	db 10 dup (0)</span><br><span class="line">cache ends</span><br><span class="line"></span><br><span class="line">stacksg segment</span><br><span class="line">        db 80 dup (0)</span><br><span class="line">stacksg ends</span><br><span class="line"> </span><br><span class="line">codesg segment</span><br><span class="line">start:	mov ax,stacksg</span><br><span class="line">	mov ss,ax</span><br><span class="line">	mov sp,80</span><br><span class="line">	mov cx,21</span><br><span class="line">	mov dx,0	;dx表示行号</span><br><span class="line"></span><br><span class="line">line:	mov si,0</span><br><span class="line">	mov bx,0</span><br><span class="line">	mov ax,data</span><br><span class="line">	mov es,ax	;使用es:[bx]来对data进行寻址</span><br><span class="line">	mov ax,table</span><br><span class="line">	mov ds,ax	;使用ds:[si]来对table进行寻址</span><br><span class="line">	</span><br><span class="line">	push cx		;将year放到table中</span><br><span class="line">	mov cx,4</span><br><span class="line">	mov ax,0</span><br><span class="line">	mov al,4</span><br><span class="line">	mul dl</span><br><span class="line">	mov bx,ax</span><br><span class="line"></span><br><span class="line">	mov ax,0</span><br><span class="line">	mov al,16</span><br><span class="line">	mul dl</span><br><span class="line">	add si,ax</span><br><span class="line">year:	mov al,es:[bx]</span><br><span class="line">	mov ds:[si],al</span><br><span class="line">	inc si</span><br><span class="line">        inc bx</span><br><span class="line">	loop year	</span><br><span class="line">	pop cx</span><br><span class="line">	</span><br><span class="line">	sub si,4</span><br><span class="line">	sub bx,4</span><br><span class="line">	push cx</span><br><span class="line">	mov cx,2</span><br><span class="line">sum:	mov ax,es:[bx+84]		;将销售额放到table	</span><br><span class="line">	mov ds:[si+5],ax</span><br><span class="line">	add bx,2</span><br><span class="line">	add si,2</span><br><span class="line">	loop sum</span><br><span class="line">	pop cx</span><br><span class="line"></span><br><span class="line">	sub si,4</span><br><span class="line">	mov al,2</span><br><span class="line">	mul dl</span><br><span class="line">	mov bx,ax</span><br><span class="line">	mov ax,es:[bx+168]		;将人数放到table	</span><br><span class="line">	mov ds:[si+10],ax</span><br><span class="line"></span><br><span class="line">	push dx</span><br><span class="line">	push cx</span><br><span class="line">	mov ax,ds:[si+5]		;计算平均数</span><br><span class="line">	mov dx,ds:[si+7]</span><br><span class="line">	div word ptr ds:[si+10]</span><br><span class="line">	mov ds:[si+13],ax</span><br><span class="line">	pop cx</span><br><span class="line">	pop dx</span><br><span class="line">	</span><br><span class="line">	call syear			;显示年份</span><br><span class="line">	call ssum			;显示销售额</span><br><span class="line">	call speo			;显示人数</span><br><span class="line">	call saver			;显示平均数</span><br><span class="line">	inc dx</span><br><span class="line">	loop line</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line"></span><br><span class="line">syear: 	   		;显示year</span><br><span class="line">	call ccache	;清理之前缓存的cache	</span><br><span class="line">	</span><br><span class="line">	push es		;将年复制到cache中，然后显示到屏幕中</span><br><span class="line">	push bx</span><br><span class="line">	push cx</span><br><span class="line">	push si</span><br><span class="line">	mov bx,0</span><br><span class="line">	mov ax,cache</span><br><span class="line">	mov es,ax</span><br><span class="line">	mov cx,4</span><br><span class="line">scy:	mov al,ds:[si]</span><br><span class="line">	mov es:[bx],al</span><br><span class="line">	inc si</span><br><span class="line">	inc bx</span><br><span class="line">	loop scy</span><br><span class="line">	pop si</span><br><span class="line">	pop cx</span><br><span class="line">	pop bx</span><br><span class="line">	pop es</span><br><span class="line">	</span><br><span class="line">	push cx</span><br><span class="line">	mov cx,2</span><br><span class="line">	call showc</span><br><span class="line">	pop cx</span><br><span class="line"></span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">;显示销售额</span><br><span class="line">ssum:	call ccache</span><br><span class="line">	push ax</span><br><span class="line">	push dx</span><br><span class="line">	mov ax,ds:[si+5]</span><br><span class="line">	mov dx,ds:[si+7]</span><br><span class="line"></span><br><span class="line">	push ds</span><br><span class="line">	push si</span><br><span class="line">	push bx</span><br><span class="line">	mov bx,cache</span><br><span class="line">	mov ds,bx</span><br><span class="line">	mov si,0</span><br><span class="line">	call dtoc</span><br><span class="line">	pop bx</span><br><span class="line">	pop si</span><br><span class="line">	pop ds</span><br><span class="line">	pop dx</span><br><span class="line">	pop ax</span><br><span class="line">	</span><br><span class="line">	push cx</span><br><span class="line">	mov cx,14</span><br><span class="line">	call showc</span><br><span class="line">	pop cx</span><br><span class="line"></span><br><span class="line">	ret</span><br><span class="line">;显示人数</span><br><span class="line">speo:	call ccache</span><br><span class="line">	push ax</span><br><span class="line">	push dx</span><br><span class="line">	mov ax,ds:[si+10]</span><br><span class="line">	mov dx,0</span><br><span class="line"></span><br><span class="line">	push ds</span><br><span class="line">	push si</span><br><span class="line">	push bx</span><br><span class="line">	mov bx,cache</span><br><span class="line">	mov ds,bx</span><br><span class="line">	mov si,0</span><br><span class="line">	call dtoc</span><br><span class="line">	pop bx</span><br><span class="line">	pop si</span><br><span class="line">	pop ds</span><br><span class="line">	pop dx</span><br><span class="line">	pop ax	</span><br><span class="line">	push cx</span><br><span class="line">	mov cx,26</span><br><span class="line">	call showc</span><br><span class="line">	pop cx</span><br><span class="line"></span><br><span class="line">	ret</span><br><span class="line">;显示平均数</span><br><span class="line">saver:	call ccache</span><br><span class="line">	push ax</span><br><span class="line">	push dx</span><br><span class="line">	mov ax,ds:[si+13]</span><br><span class="line">	mov dx,0</span><br><span class="line"></span><br><span class="line">	push ds</span><br><span class="line">	push si</span><br><span class="line">	push bx</span><br><span class="line">	mov bx,cache</span><br><span class="line">	mov ds,bx</span><br><span class="line">	mov si,0</span><br><span class="line">	call dtoc</span><br><span class="line">	pop bx</span><br><span class="line">	pop si</span><br><span class="line">	pop ds</span><br><span class="line">	pop dx</span><br><span class="line">	pop ax	</span><br><span class="line">	push cx</span><br><span class="line">	mov cx,38</span><br><span class="line">	call showc</span><br><span class="line">	pop cx</span><br><span class="line"></span><br><span class="line">	ret		</span><br><span class="line"></span><br><span class="line">;显示cache中的字符串，其中cl表示列号</span><br><span class="line">showc:	push ds</span><br><span class="line">	push si</span><br><span class="line">	push bx</span><br><span class="line">	push dx</span><br><span class="line">	push cx</span><br><span class="line">	mov bx,dx</span><br><span class="line">	inc bx			;次数加1。因为从0开始的。行数从1开始。</span><br><span class="line">	mov si,0</span><br><span class="line">	mov ax,cache</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov dh,bl</span><br><span class="line">	mov dl,cl</span><br><span class="line">	mov cl,2</span><br><span class="line">	call show_str</span><br><span class="line">	pop cx</span><br><span class="line">	pop dx</span><br><span class="line">	pop bx</span><br><span class="line">	pop si</span><br><span class="line">	pop ds</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">;清理cache</span><br><span class="line">ccache: push ds		;清理cache</span><br><span class="line">	push si</span><br><span class="line">	push cx</span><br><span class="line">	push ax</span><br><span class="line">	mov si,0</span><br><span class="line">	mov ax,cache</span><br><span class="line">	mov ds,ax</span><br><span class="line">ccstart:</span><br><span class="line">	mov cx,ds:[si]</span><br><span class="line">	jcxz ccend</span><br><span class="line">	mov byte ptr ds:[si],0</span><br><span class="line">	inc si</span><br><span class="line">	jmp short ccstart</span><br><span class="line"></span><br><span class="line">ccend:	pop ax</span><br><span class="line">	pop cx</span><br><span class="line">	pop si</span><br><span class="line">	pop ds</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">;dtoc将dword型数转变为表示十进制数的字符串，字符串以0位结尾符</span><br><span class="line">dtoc:	push bx</span><br><span class="line">        push cx</span><br><span class="line">        push di</span><br><span class="line">	push si</span><br><span class="line"></span><br><span class="line">        mov di,0</span><br><span class="line">        </span><br><span class="line">dtocl:  mov cx,0ah</span><br><span class="line">        call divdw</span><br><span class="line">        mov bx,cx</span><br><span class="line">	mov cx,ax</span><br><span class="line">        add bx,30h</span><br><span class="line">        push bx</span><br><span class="line">	inc di</span><br><span class="line">	jcxz dtocp</span><br><span class="line">        jmp short dtocl</span><br><span class="line"></span><br><span class="line">dtocp:  mov cx,di</span><br><span class="line">        jcxz dtoce</span><br><span class="line">        sub di,1</span><br><span class="line">        pop bx</span><br><span class="line">	mov [si],bl</span><br><span class="line">	inc si</span><br><span class="line">        jmp short dtocp</span><br><span class="line"></span><br><span class="line">dtoce:  pop si</span><br><span class="line">	pop di</span><br><span class="line">        pop cx</span><br><span class="line">        pop bx</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">;divdw进行不会产生溢出的除法运算</span><br><span class="line">divdw:  push bx</span><br><span class="line">        push ax</span><br><span class="line">        mov ax,dx</span><br><span class="line">        mov dx,0</span><br><span class="line">        div cx</span><br><span class="line">        mov bx,ax</span><br><span class="line"></span><br><span class="line">        pop ax</span><br><span class="line">        div cx</span><br><span class="line">        mov cx,dx</span><br><span class="line">        mov dx,bx</span><br><span class="line"></span><br><span class="line">        pop bx</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">show_str:</span><br><span class="line">        push ax</span><br><span class="line">        push bx</span><br><span class="line">        push bp</span><br><span class="line">        push es</span><br><span class="line"></span><br><span class="line">	mov ax,0b800h</span><br><span class="line">	mov es,ax</span><br><span class="line"></span><br><span class="line">        mov al,dh</span><br><span class="line">        mov ah,0</span><br><span class="line">        mov bl,0a0h</span><br><span class="line">        mul bl</span><br><span class="line">        mov bp,ax</span><br><span class="line"></span><br><span class="line">        mov ax,0</span><br><span class="line">        mov al,dl</span><br><span class="line">        mov bl,2</span><br><span class="line">        mul bl</span><br><span class="line">        add bp,ax</span><br><span class="line"></span><br><span class="line">s:      push cx</span><br><span class="line">        mov cl,[si]</span><br><span class="line">        mov ch,0</span><br><span class="line">        jcxz ok</span><br><span class="line">        pop cx</span><br><span class="line">        mov al,[si]</span><br><span class="line">        mov ah,cl</span><br><span class="line">        mov es:[bp],ax</span><br><span class="line">        inc si</span><br><span class="line">        add bp,2</span><br><span class="line">        jmp short s</span><br><span class="line"></span><br><span class="line">ok:     pop cx</span><br><span class="line">	pop es</span><br><span class="line">        pop bp</span><br><span class="line">        pop bx</span><br><span class="line">        pop ax</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>这是运行后的效果图：<br><img src="https://raw.githubusercontent.com/lengain/LengainGraphBed/master/picture/%E6%88%AA%E5%B1%8F2020-07-28%20%E4%B8%8B%E5%8D%884.09.26.png" alt><br>这个和原题中效果图不一样的地方就是没有把屏幕中的其他字符给清空。清空也是可以做的，我没这么多时间，这里就写一下思路</p>
<ul>
<li>空格的ASCII码为32，即0x20</li>
<li>根据列号和长度在屏幕上填充多个空格来覆盖其他字符</li>
<li>在转换销售额，人数，平均销售额时，可返回当前转换后字符串的长度。根据返回的长度可算出数字字符串后应填充多少空格</li>
</ul>
]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>离花别苑</title>
    <url>/2020/07/29/%E7%A6%BB%E8%8A%B1%E5%88%AB%E8%8B%91/</url>
    <content><![CDATA[<p>&emsp;&emsp;今天趴在桌子上午休，压得胳膊酸痛，索性不睡了。我未来想建个院子或是小花园，记录一下这个想法。<br>&emsp;&emsp;院子的名字叫<code>离花别苑</code>。有离别花院的意思。称它为别院，是因为我可能不会一直生活在这里，可能周末，或者假期小住。为什么起<code>离</code>这个字呢，可以理解的简单一点，也是因为我不会常住，会经常离开。如果以后想到好的名字，再改也不迟。</p>
<a id="more"></a>
<p>&emsp;&emsp;院子的名字必须刻在木板上，做成木牌挂在门上，或者做成木匾，挂在门头上。有的闲的话，我可能会学一些点木刻的技艺，自己刻。<br>&emsp;&emsp;院子里会安装一个葡萄架，葡萄架要选高一点的，等葡萄爬满架子的时候，离地远，我长得高，以防碰头，架子下可纳凉，有藤椅桌子，可看书午睡，也可弹琴高歌，也可三四人聚会。葡萄架下面会种两棵葡萄树，一棵紫葡萄，一棵绿葡萄。我估计葡萄树要爬满整个架子，估计要个二三年。<br>&emsp;&emsp;院子里面会安装一个小型水池，水池中有小型的假山，水池里面会养一些鱼，荷花以及其他合适的水生植物，把它们做一个微型的循环系统，能够保证水是流动的，活的，能够多少天不搭理也能安然无恙。<br>&emsp;&emsp;学习养花的知识是必要的，不光要学，还要学的好。要了解种植的花草的习性，是喜阴喜阳，还是喜湿喜干等，然后合理的安排植物的种植环境。等我有了足够的知识储备，可能在院子的一个角，做个玻璃房。种植一些环境要求放在玻璃房的植物。<br>&emsp;&emsp;整个院子的其他的地方会种满花草，花草之中会摆一些石头，只留铺着石板或者鹅卵石的小路，小路不要太宽，也不要太窄，够两个人并排走刚好。院子里的植物不会种植多少长得高大的树，更多的是低矮的花草，保证视野的开阔。<br>&emsp;&emsp;院子的围墙可能会传统一点，做成白墙青瓦的风格，墙上会做一些镂空的窗花砖雕，给人一种中式庭院的感觉。<br>&emsp;&emsp;美哉！</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>给设计师，产品经理的iOS UI介绍</title>
    <url>/2020/09/23/%E7%BB%99%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%9A%84iOS-UI%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>iOS为一名iOS开发者，在日常工作中常常会遇到设计师，产品经理犯一些常识性的错误，令人啼笑皆非。有些扯皮，因为没有共识，浪费了很多时间。部分设计师和产品经理对iOS系统的理解停留在表面。我这篇分享，将从程序员的角度带你去认识一下iOS系统的UI。</p>
<p>读完之后的目标：</p>
<ul>
<li><p>认识iOS操作系统中大部分系统控件的UI</p>
</li>
<li><p>理解iOS开发中视图组织的内部逻辑</p>
</li>
<li><p>一些常识</p>
</li>
<li><p>一些设计资源的分享</p>
</li>
</ul>
<a id="more"></a>

<h3 id="UIKit"><a href="#UIKit" class="headerlink" title="UIKit"></a>UIKit</h3><p>iOS系统中，用于显示界面的UI库叫<code>UIKit</code>，<code>UIKit</code>中有丰富的UI控件帮助开发者快速的构建美观，功能丰富，符合苹果设计规范的UI界面。</p>
<p>苹果官方写了一个App，用来展示UIKit中的组件，这里是<a href="https://developer.apple.com/documentation/uikit/mac_catalyst/uikit_catalog_creating_and_customizing_views_and_controls">地址</a>，如果地址失效了，请用关键字<code>Apple UIKitCatalog</code>搜索。有条件的可以自己在Mac电脑上下载Xcode软件，连接电脑安装。也可以自己找iOS开发的程序猿来帮你安装到手机上。</p>
<p>下面的分享中，我将使用这个App中的截图，来介绍UIKit中控件。</p>
<p>我的手机的iOS系统版本是<code>iOS14.0.1</code></p>
<h5 id="UIView"><a href="#UIView" class="headerlink" title="UIView"></a>UIView</h5><p><code>UIView</code>是UIKit中最基础的控件，所有其他控件都是继承于UIView。UIView相当于ps中的一个画板，即可以作为一个容器，放置其他控件视图，又可以单独当做一个空间使用。</p>
<p>UIView有以下属性：</p>
<ul>
<li><p>大小、位置、背景颜色、是否隐藏</p>
</li>
<li><p>圆角、阴影</p>
</li>
<li><p>手势触控（点击，滑动，拖动，捏合，长按）</p>
</li>
</ul>
<p>同样的，继承UIView的其他视图也都是有这些属性的。</p>
<p>下图即是一个iOS App的首页。它的可见部分全部都是由UIView及其子类控件组成的。各种控件大大小小相互嵌套就组成了各种页面。</p>
<p><img src="/2020/09/23/%E7%BB%99%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%9A%84iOS-UI%E4%BB%8B%E7%BB%8D/snapshot2020-09-30.png" alt></p>
<h5 id="各种控件"><a href="#各种控件" class="headerlink" title="各种控件"></a>各种控件</h5><p>以下控件都是继承于UIView，即UIView有的属性，它们也都有，同时它们也有UIView没有的特性。</p>
<p><strong>UIButton</strong></p>
<p><code>UIButton</code>为按钮控件，常用于点击事件。按钮可设置图片和文本。按钮是一种可设置状态的控件。比如普通状态(normal)，选中状态(selected)，高亮状态(highlighted)，禁用状态(disabled)等，开发者可以为按钮的每个状态设置不同的图片和文本。</p>
<p>下图左侧Buttons展示了各种按钮，其中标明System为系统图标。</p>
<p><img src="/2020/09/23/%E7%BB%99%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%9A%84iOS-UI%E4%BB%8B%E7%BB%8D/1.png" alt="1"></p>
<p><strong>UIPageControl</strong></p>
<p><code>UIPageControl</code>为页码控制器，通常用于指示轮播图的位置，控制器的指示视图默认为圆点。开发者可自定义页码控制器上指示视图（即上图中页面Page Control，小圆点）的图片。上图右侧图Custom Page Control为自定义指示视图的页面。</p>
<p><strong>UISearchBar</strong></p>
<p><code>UISearchBar</code>为搜索框， 下图Default Search Bar中展示的即是。搜索框可自定义搜索图标🔍的图片，以及文本的字体大小颜色，取消按钮的文本，样式等，Scope范围的设置为可选项。</p>
<p>UISearchBar和列表视图放在一起时，再搭配UISearchController，可以带动画效果的搜索视图，具体可以在iPhone-&gt;设置页面看到。</p>
<p><img src="/2020/09/23/%E7%BB%99%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%9A%84iOS-UI%E4%BB%8B%E7%BB%8D/2.png" alt="2"></p>
<p><strong>UISegmentView</strong>为分段控制器，分段控制器可以自定义各种样式，如上图Segmented Contols。开发者可以设置分段控制器按钮的背景色，选中色，甚至可以将按钮设置为图片。分段控制器通常放在页面的导航栏区域，用来分页或者分类数据，在iPhone-&gt;最近通话的导航栏区域可看到。</p>
<p><strong>UISlider</strong>为滑块，由一个进度条和拇指可拖动视图（小圆点）组成，如上图Siders中展示的那样。开发者可以自定义滑块进图条的前景色，背景色，粗细，也可以设置拇指视图（圆点）的大小颜色，样式。</p>
<p><strong>UIStepper</strong>为步进器，UI样式如下图，常用于一些较小数值值的加减操作，典型场景打印页面的页数。开发者可自定义背景色，左右加减符号的图片，分割线的图片，加减值的大小。</p>
<p><strong>UISwitch</strong>为开关。常用于设置页面某项设置的开关。</p>
<p><img src="/2020/09/23/%E7%BB%99%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%9A%84iOS-UI%E4%BB%8B%E7%BB%8D/3.png" alt="3"></p>
<p><strong>UITextField</strong>为单行输入框，常用于输入用户名，密码，或搜索。开发者可设置占位文本用于提醒，每个UITextField有左右视图，默认不显示，开发者可自定义显示，比如上图中第四个UITextField，设置了左右两个视图，开发者可设置文本大小，字体，颜色，是否是密码输入（即输入后变为黑点），视图背景色等，不过不能换行。</p>
<p><strong>UITextView</strong>为多行输入框。常用于输入较长的文本。UITextView的属性比UITextField少一些。开发者可设置文本大小，字体，颜色，不支持密文输入，支持富文本编辑，插入图片（自定义表情）等，Apple的Demo中没有UITextView的示例，你可以参考微信朋友圈发布新内容时的输入框。</p>
<p><strong>UIActivityIndicatorView</strong>是活动指示器，如下图，通常用于表示页面加载中。</p>
<p><img src="/2020/09/23/%E7%BB%99%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%9A%84iOS-UI%E4%BB%8B%E7%BB%8D/4.png" alt="4"></p>
<p><strong>UIAlertController</strong>是警告框。警告框有两种样式，一种是在屏幕中间的，如上图，可以自定义左右两边的按钮，也可以在警告框中添加单行输入框。另一种是动作表单（Action Sheet），如下图，通常用于多个可选择操作。</p>
<p><img src="/2020/09/23/%E7%BB%99%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%9A%84iOS-UI%E4%BB%8B%E7%BB%8D/5.png" alt="5"></p>
<p>UIProgressView是进度条，开发者可设置进度条的前景色，背景色，宽高等。</p>
<p>UIToolBar为工具栏，位于页面的下方，可放置一些操作按钮。</p>
<p>UIPickerView是选择器。通常用于时间，日期等数字的选择。开发者可以设置选择器的列数和行数，以及每个条目的文本信息，下图中是3列，255行。</p>
<p><img src="/2020/09/23/%E7%BB%99%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%9A%84iOS-UI%E4%BB%8B%E7%BB%8D/6.png" alt="6"></p>
<p>以上就是一些常用的苹果官方控件。</p>
<p>苹果在设计这些控件和视图时，会遵循六个设计原则，这六个设计原则放在苹果iOS<a href="https://developer.apple.com/design/human-interface-guidelines/ios/overview/themes/">人机界面指南</a>的首页。建议去官网观看。</p>
<p>苹果六大设计原则</p>
<ul>
<li><p>美学完整性(Aesthetic Integrity)</p>
</li>
<li><p>一致性(Consistency)</p>
</li>
<li><p>直接操作性(Direct Manipulation)</p>
</li>
<li><p>反馈(Feedback)</p>
</li>
<li><p>隐喻(Metaphors)</p>
</li>
<li><p>用户控制(User Control)</p>
</li>
</ul>
<p>同样，如果你想了解更多，可以去苹果设计官网进行观看学习。</p>
<p>苹果设计（<a href="https://developer.apple.com/design/resources/">https://developer.apple.com/design/resources/</a> ）</p>
<p>苹果设计相关视频（<a href="https://developer.apple.com/videos/design/">https://developer.apple.com/videos/design/</a> ）</p>
]]></content>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
</search>
